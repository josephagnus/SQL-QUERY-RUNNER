{"ast":null,"code":"import React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return arg => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return arg2 => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup(...args) {\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc(...procs) {\n  return () => {\n    procs.map(call);\n  };\n}\nfunction isDefined(arg) {\n  return arg !== void 0;\n}\nfunction noop() {}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, value => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach(subscription => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), stream2 => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), stream2 => connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n  return subscriber => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source, ...operators) {\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n  let current;\n  return done => next => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return done => value => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return done => compose(done, project);\n}\nfunction mapTo(value) {\n  return done => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return done => value => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return done => value => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue = null;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return done => value => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom(...sources) {\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return done => value => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge(...sources) {\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map(source => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source, comparator = defaultComparator) {\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n  const innerSubject = stream();\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, value => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function (action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor, dependencies = [], {\n  singleton\n} = {\n  singleton: true\n}) {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */new Map();\n  const _init = ({\n    id: id2,\n    constructor,\n    dependencies,\n    singleton\n  }) => {\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map(e => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$2 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = value => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const {\n      children,\n      ...props\n    } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), system22 => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$2(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$2(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    return React.createElement(Context.Provider, {\n      value: system2\n    }, Root ? React.createElement(Root, omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props), children) : children);\n  });\n  const usePublisher2 = key => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue2 = key => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$2(() => subscribe(source, next => {\n      if (next !== value) {\n        setValue(always(next));\n      }\n    }), [source, value]);\n    return value;\n  };\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;\nvar LogLevel = /* @__PURE__ */(LogLevel2 => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [0\n  /* DEBUG */]: \"debug\",\n  [1\n  /* INFO */]: \"log\",\n  [2\n  /* WARN */]: \"warn\",\n  [3\n  /* ERROR */]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(() => {\n  const logLevel = statefulStream(3\n  /* ERROR */);\n\n  const log = statefulStream((label, message, level = 1) => {\n    var _a;\n    const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n    if (level >= currentLevel) {\n      console[CONSOLE_METHOD_MAP[level]](\"%creact-virtuoso: %c%s %o\", \"color: #0253b3; font-weight: bold\", \"color: initial\", label, message);\n    }\n  });\n  return {\n    log,\n    logLevel\n  };\n}, [], {\n  singleton: true\n});\nfunction useSizeWithElRef(callback, enabled = true) {\n  const ref = React.useRef(null);\n  let callbackRef = _el => {};\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = React.useMemo(() => {\n      return new ResizeObserver(entries => {\n        const element = entries[0].target;\n        if (element.offsetParent !== null) {\n          callback(element);\n        }\n      });\n    }, [callback]);\n    callbackRef = elRef => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return {\n    ref,\n    callbackRef\n  };\n}\nfunction useSize(callback, enabled = true) {\n  return useSizeWithElRef(callback, enabled).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {\n  const memoedCallback = React.useCallback(el => {\n    const ranges = getChangedChildSizes(el.children, itemSize, \"offsetHeight\", log);\n    let scrollableElement = el.parentElement;\n    while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n      scrollableElement = scrollableElement.parentElement;\n    }\n    const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n    const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;\n    const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;\n    const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;\n    scrollContainerStateCallback({\n      scrollTop: Math.max(scrollTop, 0),\n      scrollHeight,\n      viewportHeight\n    });\n    gap == null ? void 0 : gap(resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n    if (ranges !== null) {\n      callback(ranges);\n    }\n  }, [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]);\n  return useSizeWithElRef(memoedCallback, enabled);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", {\n        child\n      }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({\n        startIndex: index,\n        endIndex: index,\n        size\n      });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent) {\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(ev => {\n    const el = ev.target;\n    const windowScroll = el === window || el === document;\n    const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n    const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n    const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;\n    const call2 = () => {\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n    };\n    if (ev.suppressFlushSync) {\n      call2();\n    } else {\n      ReactDOM.flushSync(call2);\n    }\n    if (scrollTopTarget.current !== null) {\n      if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n        if (timeoutRef.current) {\n          clearTimeout(timeoutRef.current);\n          timeoutRef.current = null;\n        }\n      }\n    }\n  }, [scrollContainerStateCallback, smoothScrollTargetReached]);\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({\n      target: localRef,\n      suppressFlushSync: true\n    });\n    localRef.addEventListener(\"scroll\", handler, {\n      passive: true\n    });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(correctItemSize(document.documentElement, \"height\"), document.documentElement.scrollHeight);\n      offsetHeight = window.innerHeight;\n      scrollTop = document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2.scrollHeight;\n      offsetHeight = correctItemSize(scrollerElement2, \"height\");\n      scrollTop = scrollerElement2.scrollTop;\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({\n        scrollTop,\n        scrollHeight,\n        viewportHeight: offsetHeight\n      });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    scrollerRef.current.scrollBy(location);\n  }\n  return {\n    scrollerRef,\n    scrollByCallback,\n    scrollToCallback\n  };\n}\nconst domIOSystem = system(() => {\n  const scrollContainerState = stream();\n  const scrollTop = stream();\n  const deviation = statefulStream(0);\n  const smoothScrollTargetReached = stream();\n  const statefulScrollTop = statefulStream(0);\n  const viewportHeight = stream();\n  const scrollHeight = stream();\n  const headerHeight = statefulStream(0);\n  const fixedHeaderHeight = statefulStream(0);\n  const fixedFooterHeight = statefulStream(0);\n  const footerHeight = statefulStream(0);\n  const scrollTo = stream();\n  const scrollBy = stream();\n  const scrollingInProgress = statefulStream(false);\n  connect(pipe(scrollContainerState, map(({\n    scrollTop: scrollTop2\n  }) => scrollTop2)), scrollTop);\n  connect(pipe(scrollContainerState, map(({\n    scrollHeight: scrollHeight2\n  }) => scrollHeight2)), scrollHeight);\n  connect(scrollTop, statefulScrollTop);\n  return {\n    // input\n    scrollContainerState,\n    scrollTop,\n    viewportHeight,\n    headerHeight,\n    fixedHeaderHeight,\n    fixedFooterHeight,\n    footerHeight,\n    scrollHeight,\n    smoothScrollTargetReached,\n    // signals\n    scrollTo,\n    scrollBy,\n    // state\n    statefulScrollTop,\n    deviation,\n    scrollingInProgress\n  };\n}, [], {\n  singleton: true\n});\nconst NIL_NODE = {\n  lvl: 0\n};\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n  return {\n    k,\n    v,\n    lvl,\n    l,\n    r\n  };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node)) return NIL_NODE;\n  const {\n    k,\n    l,\n    r\n  } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, {\n        k: lastKey,\n        v: lastValue,\n        l: deleteLast(l)\n      }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, {\n      l: remove(l, key)\n    }));\n  } else {\n    return adjust(clone(node, {\n      r: remove(r, key)\n    }));\n  }\n}\nfunction find(node, key) {\n  if (empty(node)) {\n    return;\n  }\n  if (key === node.k) {\n    return node.v;\n  } else if (key < node.k) {\n    return find(node.l, key);\n  } else {\n    return find(node.r, key);\n  }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (Number(node[field]) === value) {\n    return [node.k, node.v];\n  }\n  if (Number(node[field]) < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, {\n      k,\n      v\n    });\n  } else if (k < node.k) {\n    return rebalance(clone(node, {\n      l: insert(node.l, k, v)\n    }));\n  } else {\n    return rebalance(clone(node, {\n      r: insert(node.r, k, v)\n    }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const {\n    k,\n    v,\n    l,\n    r\n  } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({\n      k,\n      v\n    });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), {\n    k: node.k,\n    v: node.v\n  }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, {\n    r: deleteLast(node.r)\n  }));\n}\nfunction clone(node, args) {\n  return newAANode(args.k !== void 0 ? args.k : node.k, args.v !== void 0 ? args.v : node.v, args.lvl !== void 0 ? args.lvl : node.lvl, args.l !== void 0 ? args.l : node.l, args.r !== void 0 ? args.r : node.r);\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const {\n    l,\n    r,\n    lvl\n  } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, {\n            r: l.r.l\n          }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, {\n        lvl: lvl - 1\n      }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, {\n            l: rl.r,\n            lvl: rlvl\n          })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let {\n    index: start,\n    value\n  } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const {\n      index: nextIndex,\n      value: nextValue\n    } = parser(items[i]);\n    result.push({\n      start,\n      end: nextIndex - 1,\n      value\n    });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({\n    start,\n    end: Infinity,\n    value\n  });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, ({\n    k: index,\n    v: value\n  }) => ({\n    index,\n    value\n  }));\n}\nfunction split(node) {\n  const {\n    r,\n    lvl\n  } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, {\n    l: clone(node, {\n      r: r.l\n    }),\n    lvl: lvl + 1\n  }) : node;\n}\nfunction skew(node) {\n  const {\n    l\n  } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, {\n    r: clone(node, {\n      l: l.r\n    })\n  }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(() => {\n  const recalcInProgress = statefulStream(false);\n  return {\n    recalcInProgress\n  };\n}, [], {\n  singleton: true\n});\nfunction rangeIncludes(refRange) {\n  const {\n    size,\n    startIndex,\n    endIndex\n  } = refRange;\n  return range => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n  let recognizedOffsetItems = 0;\n  let groupIndex = 0;\n  while (recognizedOffsetItems < offset) {\n    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n    groupIndex++;\n  }\n  const offsetIsExact = recognizedOffsetItems === offset;\n  return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const {\n      size,\n      startIndex,\n      endIndex\n    } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const {\n      start: rangeStart,\n      end: rangeEnd,\n      value: rangeValue\n    } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator({\n  index: itemIndex\n}, index) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({\n  offset: itemOffset\n}, offset) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return {\n    index: point.index,\n    value: point\n  };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const {\n    start: startIndex2,\n    value\n  } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const {\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastSize,\n    lastOffset\n  } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const {\n    offset,\n    index: startIndex,\n    size\n  } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n  return walk(sizeTree).map(({\n    k: startIndex,\n    v: size\n  }, index, sizeArray) => {\n    const nextSize = sizeArray[index + 1];\n    const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n    return {\n      startIndex,\n      endIndex,\n      size\n    };\n  });\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(([{\n  log\n}, {\n  recalcInProgress\n}]) => {\n  const sizeRanges = stream();\n  const totalCount = stream();\n  const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n  const unshiftWith = stream();\n  const shiftWith = stream();\n  const firstItemIndex = statefulStream(0);\n  const groupIndices = statefulStream([]);\n  const fixedItemSize = statefulStream(void 0);\n  const defaultItemSize = statefulStream(void 0);\n  const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n  const data = statefulStream(void 0);\n  const gap = statefulStream(0);\n  const initial = initialSizeState();\n  const sizes = statefulStreamFromEmitter(pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()), initial);\n  const prevGroupIndices = statefulStreamFromEmitter(pipe(groupIndices, distinctUntilChanged(), scan((prev, curr) => ({\n    prev: prev.current,\n    current: curr\n  }), {\n    prev: [],\n    current: []\n  }), map(({\n    prev\n  }) => prev)), []);\n  connect(pipe(groupIndices, filter(indexes => indexes.length > 0), withLatestFrom(sizes, gap), map(([groupIndices2, sizes2, gap2]) => {\n    const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n      return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n    }, newTree());\n    return {\n      ...sizes2,\n      groupIndices: groupIndices2,\n      groupOffsetTree\n    };\n  })), sizes);\n  connect(pipe(totalCount, withLatestFrom(sizes), filter(([totalCount2, {\n    lastIndex\n  }]) => {\n    return totalCount2 < lastIndex;\n  }), map(([totalCount2, {\n    lastIndex,\n    lastSize\n  }]) => {\n    return [{\n      startIndex: totalCount2,\n      endIndex: lastIndex,\n      size: lastSize\n    }];\n  })), sizeRanges);\n  connect(fixedItemSize, defaultItemSize);\n  const trackItemSizes = statefulStreamFromEmitter(pipe(fixedItemSize, map(size => size === void 0)), true);\n  connect(pipe(defaultItemSize, filter(value => {\n    return value !== void 0 && empty(getValue(sizes).sizeTree);\n  }), map(size => [{\n    startIndex: 0,\n    endIndex: 0,\n    size\n  }])), sizeRanges);\n  const listRefresh = streamFromEmitter(pipe(sizeRanges, withLatestFrom(sizes), scan(({\n    sizes: oldSizes\n  }, [_, newSizes]) => {\n    return {\n      changed: newSizes !== oldSizes,\n      sizes: newSizes\n    };\n  }, {\n    changed: false,\n    sizes: initial\n  }), map(value => value.changed)));\n  subscribe(pipe(firstItemIndex, scan((prev, next) => {\n    return {\n      diff: prev.prev - next,\n      prev: next\n    };\n  }, {\n    diff: 0,\n    prev: 0\n  }), map(val => val.diff)), offset => {\n    const {\n      groupIndices: groupIndices2\n    } = getValue(sizes);\n    if (offset > 0) {\n      publish(recalcInProgress, true);\n      publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n    } else if (offset < 0) {\n      const prevGroupIndicesValue = getValue(prevGroupIndices);\n      if (prevGroupIndicesValue.length > 0) {\n        offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n      }\n      publish(shiftWith, offset);\n    }\n  });\n  subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {\n    if (index < 0) {\n      log2(\"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\", {\n        firstItemIndex\n      }, LogLevel.ERROR);\n    }\n  });\n  const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n  connect(pipe(unshiftWith, withLatestFrom(sizes), map(([unshiftWith2, sizes2]) => {\n    const groupedMode = sizes2.groupIndices.length > 0;\n    const initialRanges = [];\n    const defaultSize = sizes2.lastSize;\n    if (groupedMode) {\n      const firstGroupSize = find(sizes2.sizeTree, 0);\n      let prependedGroupItemsCount = 0;\n      let groupIndex = 0;\n      while (prependedGroupItemsCount < unshiftWith2) {\n        const theGroupIndex = sizes2.groupIndices[groupIndex];\n        const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n        initialRanges.push({\n          startIndex: theGroupIndex,\n          endIndex: theGroupIndex,\n          size: firstGroupSize\n        });\n        initialRanges.push({\n          startIndex: theGroupIndex + 1,\n          endIndex: theGroupIndex + 1 + groupItemCount - 1,\n          size: defaultSize\n        });\n        groupIndex++;\n        prependedGroupItemsCount += groupItemCount + 1;\n      }\n      const sizeTreeKV = walk(sizes2.sizeTree);\n      const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n      if (firstGroupIsExpanded) {\n        sizeTreeKV.shift();\n      }\n      return sizeTreeKV.reduce((acc, {\n        k: index,\n        v: size\n      }) => {\n        let ranges = acc.ranges;\n        if (acc.prevSize !== 0) {\n          ranges = [...acc.ranges, {\n            startIndex: acc.prevIndex,\n            endIndex: index + unshiftWith2 - 1,\n            size: acc.prevSize\n          }];\n        }\n        return {\n          ranges,\n          prevIndex: index + unshiftWith2,\n          prevSize: size\n        };\n      }, {\n        ranges: initialRanges,\n        prevIndex: unshiftWith2,\n        prevSize: 0\n      }).ranges;\n    }\n    return walk(sizes2.sizeTree).reduce((acc, {\n      k: index,\n      v: size\n    }) => {\n      return {\n        ranges: [...acc.ranges, {\n          startIndex: acc.prevIndex,\n          endIndex: index + unshiftWith2 - 1,\n          size: acc.prevSize\n        }],\n        prevIndex: index + unshiftWith2,\n        prevSize: size\n      };\n    }, {\n      ranges: [],\n      prevIndex: 0,\n      prevSize: defaultSize\n    }).ranges;\n  })), sizeRanges);\n  const shiftWithOffset = streamFromEmitter(pipe(shiftWith, withLatestFrom(sizes, gap), map(([shiftWith2, {\n    offsetTree\n  }, gap2]) => {\n    const newFirstItemIndex = -shiftWith2;\n    return offsetOf(newFirstItemIndex, offsetTree, gap2);\n  })));\n  connect(pipe(shiftWith, withLatestFrom(sizes, gap), map(([shiftWith2, sizes2, gap2]) => {\n    const groupedMode = sizes2.groupIndices.length > 0;\n    if (groupedMode) {\n      if (empty(sizes2.sizeTree)) {\n        return sizes2;\n      }\n      let newSizeTree = newTree();\n      const prevGroupIndicesValue = getValue(prevGroupIndices);\n      let removedItemsCount = 0;\n      let groupIndex = 0;\n      let groupOffset = 0;\n      while (removedItemsCount < -shiftWith2) {\n        groupOffset = prevGroupIndicesValue[groupIndex];\n        const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n        groupIndex++;\n        removedItemsCount += groupItemCount + 1;\n      }\n      newSizeTree = walk(sizes2.sizeTree).reduce((acc, {\n        k,\n        v\n      }) => {\n        return insert(acc, Math.max(0, k + shiftWith2), v);\n      }, newSizeTree);\n      const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n      if (aGroupIsShrunk) {\n        const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n        newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n        const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n        newSizeTree = insert(newSizeTree, 1, nextItemSize);\n      }\n      return {\n        ...sizes2,\n        sizeTree: newSizeTree,\n        ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n      };\n    } else {\n      const newSizeTree = walk(sizes2.sizeTree).reduce((acc, {\n        k,\n        v\n      }) => {\n        return insert(acc, Math.max(0, k + shiftWith2), v);\n      }, newTree());\n      return {\n        ...sizes2,\n        sizeTree: newSizeTree,\n        ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n      };\n    }\n  })), sizes);\n  return {\n    // input\n    data,\n    totalCount,\n    sizeRanges,\n    groupIndices,\n    defaultItemSize,\n    fixedItemSize,\n    unshiftWith,\n    shiftWith,\n    shiftWithOffset,\n    beforeUnshiftWith,\n    firstItemIndex,\n    gap,\n    // output\n    sizes,\n    listRefresh,\n    statefulTotalCount,\n    trackItemSizes,\n    itemSize\n  };\n}, tup(loggerSystem, recalcSystem), {\n  singleton: true\n});\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? {\n    index: location\n  } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(([{\n  sizes,\n  totalCount,\n  listRefresh,\n  gap\n}, {\n  scrollingInProgress,\n  viewportHeight,\n  scrollTo,\n  smoothScrollTargetReached,\n  headerHeight,\n  footerHeight,\n  fixedHeaderHeight,\n  fixedFooterHeight\n}, {\n  log\n}]) => {\n  const scrollToIndex = stream();\n  const topListHeight = statefulStream(0);\n  let unsubscribeNextListRefresh = null;\n  let cleartTimeoutRef = null;\n  let unsubscribeListRefresh = null;\n  function cleanup() {\n    if (unsubscribeNextListRefresh) {\n      unsubscribeNextListRefresh();\n      unsubscribeNextListRefresh = null;\n    }\n    if (unsubscribeListRefresh) {\n      unsubscribeListRefresh();\n      unsubscribeListRefresh = null;\n    }\n    if (cleartTimeoutRef) {\n      clearTimeout(cleartTimeoutRef);\n      cleartTimeoutRef = null;\n    }\n    publish(scrollingInProgress, false);\n  }\n  connect(pipe(scrollToIndex, withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log), withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight), map(([[location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2], gap2, fixedHeaderHeight2, fixedFooterHeight2]) => {\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    const lastIndex = totalCount2 - 1;\n    const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n    let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n    if (align === \"end\") {\n      top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n      if (index === lastIndex) {\n        top += footerHeight2;\n      }\n    } else if (align === \"center\") {\n      top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n    } else {\n      top -= topListHeight2;\n    }\n    if (offset) {\n      top += offset;\n    }\n    const retry = listChanged => {\n      cleanup();\n      if (listChanged) {\n        log2(\"retrying to scroll to\", {\n          location\n        }, LogLevel.DEBUG);\n        publish(scrollToIndex, location);\n      } else {\n        log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n      }\n    };\n    cleanup();\n    if (behavior === \"smooth\") {\n      let listChanged = false;\n      unsubscribeListRefresh = subscribe(listRefresh, changed => {\n        listChanged = listChanged || changed;\n      });\n      unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n        retry(listChanged);\n      });\n    } else {\n      unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n    }\n    cleartTimeoutRef = setTimeout(() => {\n      cleanup();\n    }, 1200);\n    publish(scrollingInProgress, true);\n    log2(\"scrolling from index to\", {\n      index,\n      top,\n      behavior\n    }, LogLevel.DEBUG);\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  return {\n    scrollToIndex,\n    topListHeight\n  };\n}, tup(sizeSystem, domIOSystem, loggerSystem), {\n  singleton: true\n});\nfunction watchChangesFor(limit) {\n  return done => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return value => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{\n  scrollContainerState,\n  scrollTop,\n  viewportHeight,\n  headerHeight,\n  footerHeight,\n  scrollBy\n}]) => {\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(pipe(merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))), distinctUntilChanged()), false);\n  const isScrollingBy = statefulStreamFromEmitter(pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()), false);\n  connect(pipe(combineLatest(duc(scrollTop), duc(atTopThreshold)), map(([top, atTopThreshold2]) => top <= atTopThreshold2), distinctUntilChanged()), isAtTop);\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(pipe(combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)), scan((current, [{\n    scrollTop: scrollTop2,\n    scrollHeight\n  }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {\n    const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n    const state = {\n      viewportHeight: viewportHeight2,\n      scrollTop: scrollTop2,\n      scrollHeight\n    };\n    if (isAtBottom2) {\n      let atBottomBecause;\n      let scrollTopDelta;\n      if (scrollTop2 > current.state.scrollTop) {\n        atBottomBecause = \"SCROLLED_DOWN\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2;\n      } else {\n        atBottomBecause = \"SIZE_DECREASED\";\n        scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n      }\n      return {\n        atBottom: true,\n        state,\n        atBottomBecause,\n        scrollTopDelta\n      };\n    }\n    let notAtBottomBecause;\n    if (state.scrollHeight > current.state.scrollHeight) {\n      notAtBottomBecause = \"SIZE_INCREASED\";\n    } else if (viewportHeight2 < current.state.viewportHeight) {\n      notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n    } else if (scrollTop2 < current.state.scrollTop) {\n      notAtBottomBecause = \"SCROLLING_UPWARDS\";\n    } else {\n      notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n    }\n    return {\n      atBottom: false,\n      notAtBottomBecause,\n      state\n    };\n  }, INITIAL_BOTTOM_STATE), distinctUntilChanged((prev, next) => {\n    return prev && prev.atBottom === next.atBottom;\n  })));\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(pipe(scrollContainerState, scan((current, {\n    scrollTop: scrollTop2,\n    scrollHeight,\n    viewportHeight: viewportHeight2\n  }) => {\n    if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n      const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n      if (current.scrollTop !== scrollTop2 && atBottom) {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: current.scrollTop - scrollTop2,\n          changed: true\n        };\n      } else {\n        return {\n          scrollHeight,\n          scrollTop: scrollTop2,\n          jump: 0,\n          changed: true\n        };\n      }\n    } else {\n      return {\n        scrollTop: scrollTop2,\n        scrollHeight,\n        jump: 0,\n        changed: false\n      };\n    }\n  }, {\n    scrollHeight: 0,\n    jump: 0,\n    scrollTop: 0,\n    changed: false\n  }), filter(value => value.changed), map(value => value.jump)), 0);\n  connect(pipe(atBottomState, map(state => state.atBottom)), isAtBottom);\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(pipe(scrollContainerState, map(({\n    scrollTop: scrollTop2\n  }) => scrollTop2), distinctUntilChanged(), scan((acc, scrollTop2) => {\n    if (getValue(isScrollingBy)) {\n      return {\n        direction: acc.direction,\n        prevScrollTop: scrollTop2\n      };\n    }\n    return {\n      direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN,\n      prevScrollTop: scrollTop2\n    };\n  }, {\n    direction: DOWN,\n    prevScrollTop: 0\n  }), map(value => value.direction)), scrollDirection);\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(pipe(isScrolling, filter(value => !value),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  mapTo(0)), scrollVelocity);\n  connect(pipe(scrollTop, throttleTime(100), withLatestFrom(isScrolling), filter(([_, isScrolling2]) => !!isScrolling2), scan(([_, prev], [next]) => [prev, next], [0, 0]), map(([prev, next]) => next - prev)), scrollVelocity);\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(([{\n  log\n}]) => {\n  const propsReady = statefulStream(false);\n  const didMount = streamFromEmitter(pipe(propsReady, filter(ready => ready), distinctUntilChanged()));\n  subscribe(propsReady, value => {\n    value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n  });\n  return {\n    propsReady,\n    didMount\n  };\n}, tup(loggerSystem), {\n  singleton: true\n});\nfunction skipFrames(frameCount, callback) {\n  if (frameCount == 0) {\n    callback();\n  } else {\n    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));\n  }\n}\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nconst initialTopMostItemIndexSystem = system(([{\n  sizes,\n  listRefresh,\n  defaultItemSize\n}, {\n  scrollTop\n}, {\n  scrollToIndex\n}, {\n  didMount\n}]) => {\n  const scrolledToInitialItem = statefulStream(true);\n  const initialTopMostItemIndex = statefulStream(0);\n  const scrollScheduled = statefulStream(false);\n  connect(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location), mapTo(false)), scrolledToInitialItem);\n  subscribe(pipe(combineLatest(listRefresh, didMount), withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, scrollScheduled), filter(([[, didMount2], scrolledToInitialItem2, {\n    sizeTree\n  }, defaultItemSize2, scrollScheduled2]) => {\n    return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled2;\n  }), withLatestFrom(initialTopMostItemIndex)), ([, initialTopMostItemIndex2]) => {\n    publish(scrollScheduled, true);\n    skipFrames(3, () => {\n      handleNext(scrollTop, () => publish(scrolledToInitialItem, true));\n      publish(scrollToIndex, initialTopMostItemIndex2);\n    });\n  });\n  return {\n    scrolledToInitialItem,\n    initialTopMostItemIndex\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem), {\n  singleton: true\n});\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(([{\n  totalCount,\n  listRefresh\n}, {\n  isAtBottom,\n  atBottomState\n}, {\n  scrollToIndex\n}, {\n  scrolledToInitialItem\n}, {\n  propsReady,\n  didMount\n}, {\n  log\n}, {\n  scrollingInProgress\n}]) => {\n  const followOutput = statefulStream(false);\n  const autoscrollToBottom = stream();\n  let pendingScrollHandle = null;\n  function scrollToBottom(followOutputBehavior) {\n    publish(scrollToIndex, {\n      index: \"LAST\",\n      align: \"end\",\n      behavior: followOutputBehavior\n    });\n  }\n  subscribe(pipe(combineLatest(pipe(duc(totalCount), skip(1)), didMount), withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress), map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {\n    let shouldFollow = didMount2 && scrolledToInitialItem2;\n    let followOutputBehavior = \"auto\";\n    if (shouldFollow) {\n      followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n      shouldFollow = shouldFollow && !!followOutputBehavior;\n    }\n    return {\n      totalCount: totalCount2,\n      shouldFollow,\n      followOutputBehavior\n    };\n  }), filter(({\n    shouldFollow\n  }) => shouldFollow)), ({\n    totalCount: totalCount2,\n    followOutputBehavior\n  }) => {\n    if (pendingScrollHandle) {\n      pendingScrollHandle();\n      pendingScrollHandle = null;\n    }\n    pendingScrollHandle = handleNext(listRefresh, () => {\n      getValue(log)(\"following output to \", {\n        totalCount: totalCount2\n      }, LogLevel.DEBUG);\n      scrollToBottom(followOutputBehavior);\n      pendingScrollHandle = null;\n    });\n  });\n  function trapNextSizeIncrease(followOutput2) {\n    const cancel = handleNext(atBottomState, state => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n        getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n        scrollToBottom(\"auto\");\n      }\n    });\n    setTimeout(cancel, 100);\n  }\n  subscribe(pipe(combineLatest(duc(followOutput), totalCount, propsReady), filter(([follow,, ready]) => follow && ready), scan(({\n    value\n  }, [, next]) => {\n    return {\n      refreshed: value === next,\n      value: next\n    };\n  }, {\n    refreshed: false,\n    value: 0\n  }), filter(({\n    refreshed\n  }) => refreshed), withLatestFrom(followOutput, totalCount)), ([, followOutput2]) => {\n    trapNextSizeIncrease(followOutput2 !== false);\n  });\n  subscribe(autoscrollToBottom, () => {\n    trapNextSizeIncrease(getValue(followOutput) !== false);\n  });\n  subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {\n    if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n      scrollToBottom(\"auto\");\n    }\n  });\n  return {\n    followOutput,\n    autoscrollToBottom\n  };\n}, tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem));\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce((acc, groupCount) => {\n    acc.groupIndices.push(acc.totalCount);\n    acc.totalCount += groupCount + 1;\n    return acc;\n  }, {\n    totalCount: 0,\n    groupIndices: []\n  });\n}\nconst groupedListSystem = system(([{\n  totalCount,\n  groupIndices,\n  sizes\n}, {\n  scrollTop,\n  headerHeight\n}]) => {\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(pipe(groupIndicesAndCount, map(value => value.totalCount)), totalCount);\n  connect(pipe(groupIndicesAndCount, map(value => value.groupIndices)), groupIndices);\n  connect(pipe(combineLatest(scrollTop, sizes, headerHeight), filter(([_, sizes2]) => hasGroups(sizes2)), map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]), distinctUntilChanged(), map(index => [index])), topItemsIndexes);\n  return {\n    groupCounts,\n    topItemsIndexes\n  };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(([{\n  scrollTop,\n  viewportHeight,\n  deviation,\n  headerHeight,\n  fixedHeaderHeight\n}]) => {\n  const listBoundary = stream();\n  const topListHeight = statefulStream(0);\n  const increaseViewportBy = statefulStream(0);\n  const overscan = statefulStream(0);\n  const visibleRange = statefulStreamFromEmitter(pipe(combineLatest(duc(scrollTop), duc(viewportHeight), duc(headerHeight), duc(listBoundary, tupleComparator), duc(overscan), duc(topListHeight), duc(fixedHeaderHeight), duc(deviation), duc(increaseViewportBy)), map(([scrollTop2, viewportHeight2, headerHeight2, [listTop, listBottom], overscan2, topListHeight2, fixedHeaderHeight2, deviation2, increaseViewportBy2]) => {\n    const top = scrollTop2 - deviation2;\n    const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n    const headerVisible = Math.max(headerHeight2 - top, 0);\n    let direction = NONE;\n    const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n    const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n    listTop -= deviation2;\n    listTop += headerHeight2 + fixedHeaderHeight2;\n    listBottom += headerHeight2 + fixedHeaderHeight2;\n    listBottom -= deviation2;\n    if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n      direction = UP;\n    }\n    if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n      direction = DOWN;\n    }\n    if (direction !== NONE) {\n      return [Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0), top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition];\n    }\n    return null;\n  }), filter(value => value != null), distinctUntilChanged(tupleComparator)), [0, 0]);\n  return {\n    // input\n    listBoundary,\n    overscan,\n    topListHeight,\n    increaseViewportBy,\n    // output\n    visibleRange\n  };\n}, tup(domIOSystem), {\n  singleton: true\n});\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [{\n      index: groupIndex,\n      size: 0,\n      offset: 0\n    }, {\n      index: itemIndex,\n      size: 0,\n      offset: 0,\n      data: data && data[0]\n    }];\n  }\n  return [{\n    index,\n    size: 0,\n    offset: 0,\n    data: data && data[0]\n  }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map(item => ({\n      ...item,\n      index: item.index + firstItemIndex,\n      originalIndex: item.index\n    }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const {\n    lastSize,\n    lastOffset,\n    lastIndex\n  } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nconst listStateSystem = system(([{\n  sizes,\n  totalCount,\n  data,\n  firstItemIndex,\n  gap\n}, groupedListSystem2, {\n  visibleRange,\n  listBoundary,\n  topListHeight: rangeTopListHeight\n}, {\n  scrolledToInitialItem,\n  initialTopMostItemIndex\n}, {\n  topListHeight\n}, stateFlags, {\n  didMount\n}, {\n  recalcInProgress\n}]) => {\n  const topItemsIndexes = statefulStream([]);\n  const itemsRendered = stream();\n  connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n  const listState = statefulStreamFromEmitter(pipe(combineLatest(didMount, recalcInProgress, duc(visibleRange, tupleComparator), duc(totalCount), duc(sizes), duc(initialTopMostItemIndex), scrolledToInitialItem, duc(topItemsIndexes), duc(firstItemIndex), duc(gap), data), filter(([mount, recalcInProgress2,, totalCount2,,,,,,, data2]) => {\n    const dataChangeInProgress = data2 && data2.length !== totalCount2;\n    return mount && !recalcInProgress2 && !dataChangeInProgress;\n  }), map(([,, [startOffset, endOffset], totalCount2, sizes2, initialTopMostItemIndex2, scrolledToInitialItem2, topItemsIndexes2, firstItemIndex2, gap2, data2]) => {\n    const sizesValue = sizes2;\n    const {\n      sizeTree,\n      offsetTree\n    } = sizesValue;\n    if (totalCount2 === 0 || startOffset === 0 && endOffset === 0) {\n      return {\n        ...EMPTY_LIST_STATE,\n        totalCount: totalCount2\n      };\n    }\n    if (empty(sizeTree)) {\n      return buildListState(probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2), [], totalCount2, gap2, sizesValue, firstItemIndex2);\n    }\n    const topItems = [];\n    if (topItemsIndexes2.length > 0) {\n      const startIndex = topItemsIndexes2[0];\n      const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n      let offset = 0;\n      for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n        const size = range.value;\n        const rangeStartIndex = Math.max(range.start, startIndex);\n        const rangeEndIndex = Math.min(range.end, endIndex);\n        for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n          topItems.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size;\n        }\n      }\n    }\n    if (!scrolledToInitialItem2) {\n      return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n    }\n    const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n    const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n    if (offsetPointRanges.length === 0) {\n      return null;\n    }\n    const maxIndex = totalCount2 - 1;\n    const items = tap([], result => {\n      for (const range of offsetPointRanges) {\n        const point = range.value;\n        let offset = point.offset;\n        let rangeStartIndex = range.start;\n        const size = point.size;\n        if (point.offset < startOffset) {\n          rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n          const itemCount = rangeStartIndex - range.start;\n          offset += itemCount * size + itemCount * gap2;\n        }\n        if (rangeStartIndex < minStartIndex) {\n          offset += (minStartIndex - rangeStartIndex) * size;\n          rangeStartIndex = minStartIndex;\n        }\n        const endIndex = Math.min(range.end, maxIndex);\n        for (let i = rangeStartIndex; i <= endIndex; i++) {\n          if (offset >= endOffset) {\n            break;\n          }\n          result.push({\n            index: i,\n            size,\n            offset,\n            data: data2 && data2[i]\n          });\n          offset += size + gap2;\n        }\n      }\n    });\n    return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n  }),\n  //@ts-expect-error filter needs to be fixed\n  filter(value => value !== null), distinctUntilChanged()), EMPTY_LIST_STATE);\n  connect(pipe(data, filter(isDefined), map(data2 => data2 == null ? void 0 : data2.length)), totalCount);\n  connect(pipe(listState, map(value => value.topListHeight)), topListHeight);\n  connect(topListHeight, rangeTopListHeight);\n  connect(pipe(listState, map(state => [state.top, state.bottom])), listBoundary);\n  connect(pipe(listState, map(state => state.items)), itemsRendered);\n  const endReached = streamFromEmitter(pipe(listState, filter(({\n    items\n  }) => items.length > 0), withLatestFrom(totalCount, data), filter(([{\n    items\n  }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1), map(([, totalCount2, data2]) => [totalCount2 - 1, data2]), distinctUntilChanged(tupleComparator), map(([count]) => count)));\n  const startReached = streamFromEmitter(pipe(listState, throttleTime(200), filter(({\n    items,\n    topItems\n  }) => {\n    return items.length > 0 && items[0].originalIndex === topItems.length;\n  }), map(({\n    items\n  }) => items[0].index), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(listState, filter(({\n    items\n  }) => items.length > 0), map(({\n    items\n  }) => {\n    let startIndex = 0;\n    let endIndex = items.length - 1;\n    while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n      startIndex++;\n    }\n    while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n      endIndex--;\n    }\n    return {\n      startIndex: items[startIndex].index,\n      endIndex: items[endIndex].index\n    };\n  }), distinctUntilChanged(rangeComparator)));\n  return {\n    listState,\n    topItemsIndexes,\n    endReached,\n    startReached,\n    rangeChanged,\n    itemsRendered,\n    ...stateFlags\n  };\n}, tup(sizeSystem, groupedListSystem, sizeRangeSystem, initialTopMostItemIndexSystem, scrollToIndexSystem, stateFlagsSystem, propsReadySystem, recalcSystem), {\n  singleton: true\n});\nconst initialItemCountSystem = system(([{\n  sizes,\n  firstItemIndex,\n  data,\n  gap\n}, {\n  listState\n}, {\n  didMount\n}]) => {\n  const initialItemCount = statefulStream(0);\n  connect(pipe(didMount, withLatestFrom(initialItemCount), filter(([, count]) => count !== 0), withLatestFrom(sizes, firstItemIndex, gap, data), map(([[, count], sizes2, firstItemIndex2, gap2, data2 = []]) => {\n    let includedGroupsCount = 0;\n    if (sizes2.groupIndices.length > 0) {\n      for (const index of sizes2.groupIndices) {\n        if (index - includedGroupsCount >= count) {\n          break;\n        }\n        includedGroupsCount++;\n      }\n    }\n    const adjustedCount = count + includedGroupsCount;\n    const items = Array.from({\n      length: adjustedCount\n    }).map((_, index) => ({\n      index,\n      size: 0,\n      offset: 0,\n      data: data2[index]\n    }));\n    return buildListState(items, [], adjustedCount, gap2, sizes2, firstItemIndex2);\n  })), listState);\n  return {\n    initialItemCount\n  };\n}, tup(sizeSystem, listStateSystem, propsReadySystem), {\n  singleton: true\n});\nconst scrollSeekSystem = system(([{\n  scrollVelocity\n}]) => {\n  const isSeeking = statefulStream(false);\n  const rangeChanged = stream();\n  const scrollSeekConfiguration = statefulStream(false);\n  connect(pipe(scrollVelocity, withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged), filter(([_, config]) => !!config), map(([speed, config, isSeeking2, range]) => {\n    const {\n      exit,\n      enter\n    } = config;\n    if (isSeeking2) {\n      if (exit(speed, range)) {\n        return false;\n      }\n    } else {\n      if (enter(speed, range)) {\n        return true;\n      }\n    }\n    return isSeeking2;\n  }), distinctUntilChanged()), isSeeking);\n  subscribe(pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)), ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range));\n  return {\n    isSeeking,\n    scrollSeekConfiguration,\n    scrollVelocity,\n    scrollSeekRangeChanged: rangeChanged\n  };\n}, tup(stateFlagsSystem), {\n  singleton: true\n});\nconst topItemCountSystem = system(([{\n  topItemsIndexes\n}]) => {\n  const topItemCount = statefulStream(0);\n  connect(pipe(topItemCount, filter(length => length > 0), map(length => Array.from({\n    length\n  }).map((_, index) => index))), topItemsIndexes);\n  return {\n    topItemCount\n  };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(([{\n  footerHeight,\n  headerHeight,\n  fixedHeaderHeight,\n  fixedFooterHeight\n}, {\n  listState\n}]) => {\n  const totalListHeightChanged = stream();\n  const totalListHeight = statefulStreamFromEmitter(pipe(combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState), map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {\n    return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n  })), 0);\n  connect(duc(totalListHeight), totalListHeightChanged);\n  return {\n    totalListHeight,\n    totalListHeightChanged\n  };\n}, tup(domIOSystem, listStateSystem), {\n  singleton: true\n});\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(([{\n  scrollBy,\n  scrollTop,\n  deviation,\n  scrollingInProgress\n}, {\n  isScrolling,\n  isAtBottom,\n  scrollDirection,\n  lastJumpDueToItemResize\n}, {\n  listState\n}, {\n  beforeUnshiftWith,\n  shiftWithOffset,\n  sizes,\n  gap\n}, {\n  log\n}, {\n  recalcInProgress\n}]) => {\n  const deviationOffset = streamFromEmitter(pipe(listState, withLatestFrom(lastJumpDueToItemResize), scan(([, prevItems, prevTotalCount, prevTotalHeight], [{\n    items,\n    totalCount,\n    bottom,\n    offsetBottom\n  }, lastJumpDueToItemResize2]) => {\n    const totalHeight = bottom + offsetBottom;\n    let newDev = 0;\n    if (prevTotalCount === totalCount) {\n      if (prevItems.length > 0 && items.length > 0) {\n        const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n        if (!atStart) {\n          newDev = totalHeight - prevTotalHeight;\n          if (newDev !== 0) {\n            newDev += lastJumpDueToItemResize2;\n          }\n        }\n      }\n    }\n    return [newDev, items, totalCount, totalHeight];\n  }, [0, [], 0, 0]), filter(([amount]) => amount !== 0), withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress), filter(([, scrollTop2, scrollDirection2, scrollingInProgress2,,, recalcInProgress2]) => {\n    return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n  }), map(([[amount],,,,, log2]) => {\n    log2(\"Upward scrolling compensation\", {\n      amount\n    }, LogLevel.DEBUG);\n    return amount;\n  })));\n  function scrollByWith(offset) {\n    if (offset > 0) {\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n      publish(deviation, 0);\n    } else {\n      publish(deviation, 0);\n      publish(scrollBy, {\n        top: -offset,\n        behavior: \"auto\"\n      });\n    }\n  }\n  subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {\n    if (isScrolling2 && isMobileSafari()) {\n      publish(deviation, deviationAmount - offset);\n    } else {\n      scrollByWith(-offset);\n    }\n  });\n  subscribe(pipe(combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress), filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0), map(([_, deviation2]) => deviation2), throttleTime(1)), scrollByWith);\n  connect(pipe(shiftWithOffset, map(offset => {\n    return {\n      top: -offset\n    };\n  })), scrollBy);\n  subscribe(pipe(beforeUnshiftWith, withLatestFrom(sizes, gap), map(([offset, {\n    lastSize: defaultItemSize,\n    groupIndices,\n    sizeTree\n  }, gap2]) => {\n    function getItemOffset(itemCount) {\n      return itemCount * (defaultItemSize + gap2);\n    }\n    if (groupIndices.length === 0) {\n      return getItemOffset(offset);\n    } else {\n      let amount = 0;\n      const defaultGroupSize = find(sizeTree, 0);\n      let recognizedOffsetItems = 0;\n      let groupIndex = 0;\n      while (recognizedOffsetItems < offset) {\n        recognizedOffsetItems++;\n        amount += defaultGroupSize;\n        let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n        if (recognizedOffsetItems + groupItemCount > offset) {\n          amount -= defaultGroupSize;\n          groupItemCount = offset - recognizedOffsetItems + 1;\n        }\n        recognizedOffsetItems += groupItemCount;\n        amount += getItemOffset(groupItemCount);\n        groupIndex++;\n      }\n      return amount;\n    }\n  })), offset => {\n    publish(deviation, offset);\n    requestAnimationFrame(() => {\n      publish(scrollBy, {\n        top: offset\n      });\n      requestAnimationFrame(() => {\n        publish(deviation, 0);\n        publish(recalcInProgress, false);\n      });\n    });\n  });\n  return {\n    deviation\n  };\n}, tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem));\nconst initialScrollTopSystem = system(([{\n  didMount\n}, {\n  scrollTo\n}, {\n  listState\n}]) => {\n  const initialScrollTop = statefulStream(0);\n  subscribe(pipe(didMount, withLatestFrom(initialScrollTop), filter(([, offset]) => offset !== 0), map(([, offset]) => ({\n    top: offset\n  }))), location => {\n    handleNext(pipe(listState, skip(1), filter(state => state.items.length > 1)), () => {\n      requestAnimationFrame(() => {\n        publish(scrollTo, location);\n      });\n    });\n  });\n  return {\n    initialScrollTop\n  };\n}, tup(propsReadySystem, domIOSystem, listStateSystem), {\n  singleton: true\n});\nconst alignToBottomSystem = system(([{\n  viewportHeight\n}, {\n  totalListHeight\n}]) => {\n  const alignToBottom = statefulStream(false);\n  const paddingTopAddition = statefulStreamFromEmitter(pipe(combineLatest(alignToBottom, viewportHeight, totalListHeight), filter(([enabled]) => enabled), map(([, viewportHeight2, totalListHeight2]) => {\n    return Math.max(0, viewportHeight2 - totalListHeight2);\n  }), throttleTime(0), distinctUntilChanged()), 0);\n  return {\n    alignToBottom,\n    paddingTopAddition\n  };\n}, tup(domIOSystem, totalListHeightSystem), {\n  singleton: true\n});\nconst windowScrollerSystem = system(([{\n  scrollTo,\n  scrollContainerState\n}]) => {\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(pipe(combineLatest(windowScrollContainerState, windowViewportRect), map(([{\n    viewportHeight,\n    scrollTop: windowScrollTop,\n    scrollHeight\n  }, {\n    offsetTop\n  }]) => {\n    return {\n      scrollTop: Math.max(0, windowScrollTop - offsetTop),\n      scrollHeight,\n      viewportHeight\n    };\n  })), scrollContainerState);\n  connect(pipe(scrollTo, withLatestFrom(windowViewportRect), map(([scrollTo2, {\n    offsetTop\n  }]) => {\n    return {\n      ...scrollTo2,\n      top: scrollTo2.top + offsetTop\n    };\n  })), windowScrollTo);\n  return {\n    // config\n    useWindowScroll,\n    customScrollParent,\n    // input\n    windowScrollContainerState,\n    windowViewportRect,\n    // signals\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = ({\n  itemTop: itemTop2,\n  itemBottom,\n  viewportTop,\n  viewportBottom,\n  locationParams: {\n    behavior,\n    align,\n    ...rest\n  }\n}) => {\n  if (itemTop2 < viewportTop) {\n    return {\n      ...rest,\n      behavior,\n      align: align != null ? align : \"start\"\n    };\n  }\n  if (itemBottom > viewportBottom) {\n    return {\n      ...rest,\n      behavior,\n      align: align != null ? align : \"end\"\n    };\n  }\n  return null;\n};\nconst scrollIntoViewSystem = system(([{\n  sizes,\n  totalCount,\n  gap\n}, {\n  scrollTop,\n  viewportHeight,\n  headerHeight,\n  fixedHeaderHeight,\n  fixedFooterHeight,\n  scrollingInProgress\n}, {\n  scrollToIndex\n}]) => {\n  const scrollIntoView = stream();\n  connect(pipe(scrollIntoView, withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop), withLatestFrom(gap), map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {\n    const {\n      done,\n      behavior,\n      align,\n      calculateViewLocation = defaultCalculateViewLocation,\n      ...rest\n    } = viewLocation;\n    const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n    const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n    const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n    const viewportTop = scrollTop2 + fixedHeaderHeight2;\n    const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n    const location = calculateViewLocation({\n      itemTop: itemTop2,\n      itemBottom,\n      viewportTop,\n      viewportBottom,\n      locationParams: {\n        behavior,\n        align,\n        ...rest\n      }\n    });\n    if (location) {\n      done && handleNext(pipe(scrollingInProgress, filter(value => value === false),\n      // skips the initial publish of false, and the cleanup call.\n      // but if scrollingInProgress is true, we skip the initial publish.\n      skip(getValue(scrollingInProgress) ? 1 : 2)), done);\n    } else {\n      done && done();\n    }\n    return location;\n  }), filter(value => value !== null)), scrollToIndex);\n  return {\n    scrollIntoView\n  };\n}, tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem), {\n  singleton: true\n});\nconst stateLoadSystem = system(([{\n  sizes,\n  sizeRanges\n}, {\n  scrollTop\n}, {\n  initialTopMostItemIndex\n}, {\n  didMount\n}]) => {\n  const getState = stream();\n  const restoreStateFrom = statefulStream(void 0);\n  subscribe(pipe(getState, withLatestFrom(sizes, scrollTop)), ([callback, sizes2, scrollTop2]) => {\n    const ranges = sizeTreeToRanges(sizes2.sizeTree);\n    callback({\n      ranges,\n      scrollTop: scrollTop2\n    });\n  });\n  connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n  connect(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, state]) => state !== void 0), distinctUntilChanged(), map(([, snapshot]) => {\n    return snapshot.ranges;\n  })), sizeRanges);\n  return {\n    getState,\n    restoreStateFrom\n  };\n}, tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem));\nfunction locationFromSnapshot(snapshot) {\n  return {\n    offset: snapshot.scrollTop,\n    index: 0,\n    align: \"start\"\n  };\n}\nconst featureGroup1System = system(([sizeRange, initialItemCount, propsReady, scrollSeek, totalListHeight, initialScrollTopSystem2, alignToBottom, windowScroller, scrollIntoView, logger]) => {\n  return {\n    ...sizeRange,\n    ...initialItemCount,\n    ...propsReady,\n    ...scrollSeek,\n    ...totalListHeight,\n    ...initialScrollTopSystem2,\n    ...alignToBottom,\n    ...windowScroller,\n    ...scrollIntoView,\n    ...logger\n  };\n}, tup(sizeRangeSystem, initialItemCountSystem, propsReadySystem, scrollSeekSystem, totalListHeightSystem, initialScrollTopSystem, alignToBottomSystem, windowScrollerSystem, scrollIntoViewSystem, loggerSystem));\nconst listSystem = system(([{\n  totalCount,\n  sizeRanges,\n  fixedItemSize,\n  defaultItemSize,\n  trackItemSizes,\n  itemSize,\n  data,\n  firstItemIndex,\n  groupIndices,\n  statefulTotalCount,\n  gap,\n  sizes\n}, {\n  initialTopMostItemIndex,\n  scrolledToInitialItem\n}, domIO, stateLoad, followOutput, {\n  listState,\n  topItemsIndexes,\n  ...flags\n}, {\n  scrollToIndex\n}, _, {\n  topItemCount\n}, {\n  groupCounts\n}, featureGroup1]) => {\n  connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n  connect(pipe(featureGroup1.windowViewportRect, map(value => value.visibleHeight)), domIO.viewportHeight);\n  return {\n    // input\n    totalCount,\n    data,\n    firstItemIndex,\n    sizeRanges,\n    initialTopMostItemIndex,\n    scrolledToInitialItem,\n    topItemsIndexes,\n    topItemCount,\n    groupCounts,\n    fixedItemHeight: fixedItemSize,\n    defaultItemHeight: defaultItemSize,\n    gap,\n    ...followOutput,\n    // output\n    statefulTotalCount,\n    listState,\n    scrollToIndex,\n    trackItemSizes,\n    itemSize,\n    groupIndices,\n    // exported from stateFlagsSystem\n    ...flags,\n    // the bag of IO from featureGroup1System\n    ...featureGroup1,\n    ...domIO,\n    sizes,\n    ...stateLoad\n  };\n}, tup(sizeSystem, initialTopMostItemIndexSystem, domIOSystem, stateLoadSystem, followOutputSystem, listStateSystem, scrollToIndexSystem, upwardScrollFixSystem, topItemCountSystem, groupedListSystem, featureGroup1System));\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(element => {\n    if (element === null || !element.offsetParent) {\n      return;\n    }\n    const rect = element.getBoundingClientRect();\n    const visibleWidth = rect.width;\n    let visibleHeight, offsetTop;\n    if (customScrollParent) {\n      const customScrollParentRect = customScrollParent.getBoundingClientRect();\n      const deltaTop = rect.top - customScrollParentRect.top;\n      visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n      offsetTop = deltaTop + customScrollParent.scrollTop;\n    } else {\n      visibleHeight = window.innerHeight - Math.max(0, rect.top);\n      offsetTop = rect.top + window.pageYOffset;\n    }\n    viewportInfo.current = {\n      offsetTop,\n      visibleHeight,\n      visibleWidth\n    };\n    callback(viewportInfo.current);\n  }, [callback, customScrollParent]);\n  const {\n    callbackRef,\n    ref\n  } = useSizeWithElRef(calculateInfo);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(scrollAndResizeEventHandler);\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream(index => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */system(([listSystem2, propsSystem]) => {\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({\n  height\n}) => /* @__PURE__ */React.createElement(\"div\", {\n  style: {\n    height\n  }\n});\nconst GROUP_STYLE = {\n  position: positionStickyCssValue(),\n  zIndex: 1,\n  overflowAnchor: \"none\"\n};\nconst ITEM_STYLE$1 = {\n  overflowAnchor: \"none\"\n};\nconst Items$1 = /* @__PURE__ */React.memo(function VirtuosoItems({\n  showTopList = false\n}) {\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const {\n    callbackRef\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, showTopList ? noop : scrollContainerStateCallback, log, listGap, customScrollParent);\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", value => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const paddingTopAddition = useEmitterValue$2(\"paddingTopAddition\");\n  const scrolledToInitialItem = useEmitterValue$2(\"scrolledToInitialItem\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    paddingTop: listState.offsetTop + paddingTopAddition,\n    paddingBottom: listState.offsetBottom,\n    marginTop: deviation,\n    ...(scrolledToInitialItem ? {} : {\n      visibility: \"hidden\"\n    })\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  return React.createElement(ListComponent, {\n    ...contextPropIfNotDomElement(ListComponent, context),\n    ref: callbackRef,\n    style: containerStyle,\n    \"data-test-id\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n  }, (showTopList ? listState.topItems : listState.items).map(item => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\",\n        ...(item.type === \"group\" ? {} : {\n          groupIndex: item.groupIndex\n        })\n      });\n    }\n    if (item.type === \"group\") {\n      return React.createElement(GroupComponent, {\n        ...contextPropIfNotDomElement(GroupComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        style: GROUP_STYLE\n      }, groupContent(item.index, context));\n    } else {\n      return React.createElement(ItemComponent, {\n        ...contextPropIfNotDomElement(ItemComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        \"data-item-group-index\": item.groupIndex,\n        item: item.data,\n        style: ITEM_STYLE$1\n      }, hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context));\n    }\n  }));\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst viewportStyle = {\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0\n};\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return {\n    context\n  };\n}\nconst Header$1 = /* @__PURE__ */React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize(el => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer$1 = /* @__PURE__ */React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize(el => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nfunction buildScroller({\n  usePublisher: usePublisher2,\n  useEmitter: useEmitter2,\n  useEmitterValue: useEmitterValue2\n}) {\n  const Scroller2 = React.memo(function VirtuosoScroller({\n    style,\n    children,\n    ...props\n  }) {\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, scrollerRefCallback);\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(ScrollerComponent, {\n      ref: scrollerRef,\n      style: {\n        ...scrollerStyle,\n        ...style\n      },\n      \"data-test-id\": \"virtuoso-scroller\",\n      \"data-virtuoso-scroller\": true,\n      tabIndex: 0,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context)\n    }, children);\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller({\n  usePublisher: usePublisher2,\n  useEmitter: useEmitter2,\n  useEmitterValue: useEmitterValue2\n}) {\n  const Scroller2 = React.memo(function VirtuosoWindowScroller({\n    style,\n    children,\n    ...props\n  }) {\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const {\n      scrollerRef,\n      scrollByCallback,\n      scrollToCallback\n    } = useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, ScrollerComponent, noop, customScrollParent);\n    useIsomorphicLayoutEffect$1(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(ScrollerComponent, {\n      style: {\n        position: \"relative\",\n        ...style,\n        ...(totalListHeight !== 0 ? {\n          height: totalListHeight + deviation\n        } : {})\n      },\n      \"data-virtuoso-scroller\": true,\n      ...props,\n      ...contextPropIfNotDomElement(ScrollerComponent, context)\n    }, children);\n  });\n  return Scroller2;\n}\nconst Viewport$2 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, el => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\"\n  }, children);\n};\nconst WindowViewport$2 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle,\n    \"data-viewport-type\": \"window\"\n  }, children);\n};\nconst TopItemListContainer = ({\n  children\n}) => {\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\");\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = {\n    ...topItemListStyle,\n    marginTop: `${headerHeight}px`\n  };\n  const context = useEmitterValue$2(\"context\");\n  return React.createElement(TopItemList || \"div\", {\n    style,\n    context\n  }, children);\n};\nconst ListRoot = /* @__PURE__ */React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, showTopList && /* @__PURE__ */React.createElement(TopItemListContainer, null, /* @__PURE__ */React.createElement(Items$1, {\n    showTopList: true\n  })), /* @__PURE__ */React.createElement(TheViewport, null, /* @__PURE__ */React.createElement(Header$1, null), /* @__PURE__ */React.createElement(Items$1, null), /* @__PURE__ */React.createElement(Footer$1, null)));\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */systemToComponent(combinedSystem$2, {\n  required: {},\n  optional: {\n    restoreStateFrom: \"restoreStateFrom\",\n    context: \"context\",\n    followOutput: \"followOutput\",\n    itemContent: \"itemContent\",\n    groupContent: \"groupContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    groupCounts: \"groupCounts\",\n    topItemCount: \"topItemCount\",\n    firstItemIndex: \"firstItemIndex\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    autoscrollToBottom: \"autoscrollToBottom\",\n    getState: \"getState\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, ListRoot);\nconst Scroller$2 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst WindowScroller$2 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n});\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{\n    index: 0\n  }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst {\n  round,\n  ceil,\n  floor,\n  min,\n  max\n} = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({\n    length: endIndex - startIndex + 1\n  }).map((_, i) => {\n    const dataItem = data === null ? null : data[i + startIndex];\n    return {\n      index: i + startIndex,\n      data: dataItem\n    };\n  });\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */system(([{\n  overscan,\n  visibleRange,\n  listBoundary\n}, {\n  scrollTop,\n  viewportHeight,\n  scrollBy,\n  scrollTo,\n  smoothScrollTargetReached,\n  scrollContainerState,\n  footerHeight,\n  headerHeight\n}, stateFlags, scrollSeek, {\n  propsReady,\n  didMount\n}, {\n  windowViewportRect,\n  useWindowScroll,\n  customScrollParent,\n  windowScrollContainerState,\n  windowScrollTo\n}, log]) => {\n  const totalCount = statefulStream(0);\n  const initialItemCount = statefulStream(0);\n  const gridState = statefulStream(INITIAL_GRID_STATE);\n  const viewportDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const itemDimensions = statefulStream({\n    height: 0,\n    width: 0\n  });\n  const scrollToIndex = stream();\n  const scrollHeight = stream();\n  const deviation = statefulStream(0);\n  const data = statefulStream(null);\n  const gap = statefulStream({\n    row: 0,\n    column: 0\n  });\n  const stateChanged = stream();\n  const restoreStateFrom = stream();\n  const stateRestoreInProgress = statefulStream(false);\n  const initialTopMostItemIndex = statefulStream(0);\n  const scrolledToInitialItem = statefulStream(true);\n  const scrollScheduled = statefulStream(false);\n  subscribe(pipe(didMount, withLatestFrom(initialTopMostItemIndex), filter(([_, location]) => !!location)), () => {\n    publish(scrolledToInitialItem, false);\n    publish(initialItemCount, 0);\n  });\n  subscribe(pipe(combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled), filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2,, scrollScheduled2]) => {\n    return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;\n  })), ([,,,, initialTopMostItemIndex2]) => {\n    publish(scrollScheduled, true);\n    skipFrames(1, () => {\n      publish(scrollToIndex, initialTopMostItemIndex2);\n    });\n    handleNext(pipe(scrollTop), () => {\n      publish(listBoundary, [0, 0]);\n      publish(scrolledToInitialItem, true);\n    });\n  });\n  connect(pipe(restoreStateFrom, filter(value => value !== void 0 && value !== null && value.scrollTop > 0), mapTo(0)), initialItemCount);\n  subscribe(pipe(didMount, withLatestFrom(restoreStateFrom), filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)), ([, snapshot]) => {\n    if (!snapshot) {\n      return;\n    }\n    publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);\n    publish(gap, snapshot.gap);\n    if (snapshot.scrollTop > 0) {\n      publish(stateRestoreInProgress, true);\n      handleNext(pipe(scrollTop, skip(1)), _value => {\n        publish(stateRestoreInProgress, false);\n      });\n      publish(scrollTo, {\n        top: snapshot.scrollTop\n      });\n    }\n  });\n  connect(pipe(viewportDimensions, map(({\n    height\n  }) => height)), viewportHeight);\n  connect(pipe(combineLatest(duc(viewportDimensions, dimensionComparator), duc(itemDimensions, dimensionComparator), duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row), duc(scrollTop)), map(([viewport, item, gap2, scrollTop2]) => ({\n    viewport,\n    item,\n    gap: gap2,\n    scrollTop: scrollTop2\n  }))), stateChanged);\n  connect(pipe(combineLatest(duc(totalCount), visibleRange, duc(gap, gapComparator), duc(itemDimensions, dimensionComparator), duc(viewportDimensions, dimensionComparator), duc(data), duc(initialItemCount), duc(stateRestoreInProgress), duc(scrolledToInitialItem), duc(initialTopMostItemIndex)), filter(([,,,,,,, stateRestoreInProgress2]) => {\n    return !stateRestoreInProgress2;\n  }), map(([totalCount2, [startOffset, endOffset], gap2, item, viewport, data2, initialItemCount2,, scrolledToInitialItem2, initialTopMostItemIndex2]) => {\n    const {\n      row: rowGap,\n      column: columnGap\n    } = gap2;\n    const {\n      height: itemHeight,\n      width: itemWidth\n    } = item;\n    const {\n      width: viewportWidth\n    } = viewport;\n    if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {\n      return INITIAL_GRID_STATE;\n    }\n    if (itemWidth === 0) {\n      const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);\n      const endIndex2 = startIndex2 === 0 ? Math.max(initialItemCount2 - 1, 0) : startIndex2;\n      return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));\n    }\n    const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n    let startIndex;\n    let endIndex;\n    if (!scrolledToInitialItem2) {\n      startIndex = 0;\n      endIndex = -1;\n    } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {\n      startIndex = 0;\n      endIndex = initialItemCount2 - 1;\n    } else {\n      startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n      endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n      endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n      startIndex = min(endIndex, max(0, startIndex));\n    }\n    const items = buildItems(startIndex, endIndex, data2);\n    const {\n      top,\n      bottom\n    } = gridLayout(viewport, gap2, item, items);\n    const rowCount = ceil(totalCount2 / perRow);\n    const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n    const offsetBottom = totalHeight - bottom;\n    return {\n      items,\n      offsetTop: top,\n      offsetBottom,\n      top,\n      bottom,\n      itemHeight,\n      itemWidth\n    };\n  })), gridState);\n  connect(pipe(data, filter(data2 => data2 !== null), map(data2 => data2.length)), totalCount);\n  connect(pipe(combineLatest(viewportDimensions, itemDimensions, gridState, gap), filter(([viewportDimensions2, itemDimensions2, {\n    items\n  }]) => {\n    return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;\n  }), map(([viewportDimensions2, itemDimensions2, {\n    items\n  }, gap2]) => {\n    const {\n      top,\n      bottom\n    } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);\n    return [top, bottom];\n  }), distinctUntilChanged(tupleComparator)), listBoundary);\n  const hasScrolled = statefulStream(false);\n  connect(pipe(scrollTop, withLatestFrom(hasScrolled), map(([scrollTop2, hasScrolled2]) => {\n    return hasScrolled2 || scrollTop2 !== 0;\n  })), hasScrolled);\n  const endReached = streamFromEmitter(pipe(duc(gridState), filter(({\n    items\n  }) => items.length > 0), withLatestFrom(totalCount, hasScrolled), filter(([{\n    items\n  }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1), map(([, totalCount2]) => totalCount2 - 1), distinctUntilChanged()));\n  const startReached = streamFromEmitter(pipe(duc(gridState), filter(({\n    items\n  }) => {\n    return items.length > 0 && items[0].index === 0;\n  }),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  mapTo(0), distinctUntilChanged()));\n  const rangeChanged = streamFromEmitter(pipe(duc(gridState), withLatestFrom(stateRestoreInProgress), filter(([{\n    items\n  }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2), map(([{\n    items\n  }]) => {\n    return {\n      startIndex: items[0].index,\n      endIndex: items[items.length - 1].index\n    };\n  }), distinctUntilChanged(rangeComparator), throttleTime(0)));\n  connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n  connect(pipe(scrollToIndex, withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap), map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {\n    const normalLocation = normalizeIndexLocation(location);\n    const {\n      align,\n      behavior,\n      offset\n    } = normalLocation;\n    let index = normalLocation.index;\n    if (index === \"LAST\") {\n      index = totalCount2 - 1;\n    }\n    index = max(0, index, min(totalCount2 - 1, index));\n    let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);\n    if (align === \"end\") {\n      top = round(top - viewportDimensions2.height + itemDimensions2.height);\n    } else if (align === \"center\") {\n      top = round(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);\n    }\n    if (offset) {\n      top += offset;\n    }\n    return {\n      top,\n      behavior\n    };\n  })), scrollTo);\n  const totalListHeight = statefulStreamFromEmitter(pipe(gridState, map(gridState2 => {\n    return gridState2.offsetBottom + gridState2.bottom;\n  })), 0);\n  connect(pipe(windowViewportRect, map(viewportInfo => ({\n    width: viewportInfo.visibleWidth,\n    height: viewportInfo.visibleHeight\n  }))), viewportDimensions);\n  return {\n    // input\n    data,\n    totalCount,\n    viewportDimensions,\n    itemDimensions,\n    scrollTop,\n    scrollHeight,\n    overscan,\n    scrollBy,\n    scrollTo,\n    scrollToIndex,\n    smoothScrollTargetReached,\n    windowViewportRect,\n    windowScrollTo,\n    useWindowScroll,\n    customScrollParent,\n    windowScrollContainerState,\n    deviation,\n    scrollContainerState,\n    footerHeight,\n    headerHeight,\n    initialItemCount,\n    gap,\n    restoreStateFrom,\n    ...scrollSeek,\n    initialTopMostItemIndex,\n    // output\n    gridState,\n    totalListHeight,\n    ...stateFlags,\n    startReached,\n    endReached,\n    rangeChanged,\n    stateChanged,\n    propsReady,\n    stateRestoreInProgress,\n    ...log\n  };\n}, tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem));\nfunction gridLayout(viewport, gap, item, items) {\n  const {\n    height: itemHeight\n  } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return {\n    top,\n    bottom\n  };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */system(([gridSystem2, gridComponentPropsSystem2]) => {\n  return {\n    ...gridSystem2,\n    ...gridComponentPropsSystem2\n  };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const stateRestoreInProgress = useEmitterValue$1(\"stateRestoreInProgress\");\n  const listRef = useSize(el => {\n    const scrollHeight = el.parentElement.parentElement.scrollHeight;\n    scrollHeightCallback(scrollHeight);\n    const firstItem = el.firstChild;\n    if (firstItem) {\n      const {\n        width,\n        height\n      } = firstItem.getBoundingClientRect();\n      itemDimensions({\n        width,\n        height\n      });\n    }\n    gridGap({\n      row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n      column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n    });\n  });\n  if (stateRestoreInProgress) {\n    return null;\n  }\n  return React.createElement(ListComponent, {\n    ref: listRef,\n    className: listClassName,\n    ...contextPropIfNotDomElement(ListComponent, context),\n    style: {\n      paddingTop: gridState.offsetTop,\n      paddingBottom: gridState.offsetBottom\n    },\n    \"data-test-id\": \"virtuoso-item-list\"\n  }, gridState.items.map(item => {\n    const key = computeItemKey(item.index, item.data, context);\n    return isSeeking ? React.createElement(ScrollSeekPlaceholder, {\n      key,\n      ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n      index: item.index,\n      height: gridState.itemHeight,\n      width: gridState.itemWidth\n    }) : React.createElement(ItemComponent, {\n      ...contextPropIfNotDomElement(ItemComponent, context),\n      className: itemClassName,\n      \"data-index\": item.index,\n      key\n    }, itemContent(item.index, item.data, context));\n  }));\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(el => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(el => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, {\n    ref\n  }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nconst Viewport$1 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize(el => {\n    viewportDimensions(el.getBoundingClientRect());\n  });\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({\n        height: ctx.viewportHeight,\n        width: ctx.viewportWidth\n      });\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef\n  }, children);\n};\nconst WindowViewport$1 = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({\n        height: ctx.itemHeight,\n        width: ctx.itemWidth\n      });\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: ctx.viewportWidth\n      });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle\n  }, children);\n};\nconst GridRoot = /* @__PURE__ */React.memo(function GridRoot2({\n  ...props\n}) {\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, /* @__PURE__ */React.createElement(TheViewport, null, /* @__PURE__ */React.createElement(Header, null), /* @__PURE__ */React.createElement(GridItems, null), /* @__PURE__ */React.createElement(Footer, null)));\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */systemToComponent(combinedSystem$1, {\n  optional: {\n    context: \"context\",\n    totalCount: \"totalCount\",\n    overscan: \"overscan\",\n    itemContent: \"itemContent\",\n    components: \"components\",\n    computeItemKey: \"computeItemKey\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    headerFooterTag: \"headerFooterTag\",\n    listClassName: \"listClassName\",\n    itemClassName: \"itemClassName\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\",\n    restoreStateFrom: \"restoreStateFrom\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\"\n  },\n  methods: {\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\",\n    scrollToIndex: \"scrollToIndex\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    stateChanged: \"stateChanged\"\n  }\n}, GridRoot);\nconst Scroller$1 = /* @__PURE__ */buildScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nconst WindowScroller$1 = /* @__PURE__ */buildWindowScroller({\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n});\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */system(() => {\n  const itemContent = statefulStream(index => /* @__PURE__ */React.createElement(\"td\", null, \"Item $\", index));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(pipe(components, map(components2 => components2[propName]), distinctUntilChanged()), defaultValue);\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */system(([listSystem2, propsSystem]) => {\n  return {\n    ...listSystem2,\n    ...propsSystem\n  };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({\n  height\n}) => /* @__PURE__ */React.createElement(\"tr\", null, /* @__PURE__ */React.createElement(\"td\", {\n  style: {\n    height\n  }\n}));\nconst DefaultFillerRow = ({\n  height\n}) => /* @__PURE__ */React.createElement(\"tr\", null, /* @__PURE__ */React.createElement(\"td\", {\n  style: {\n    height,\n    padding: 0,\n    border: 0\n  }\n}));\nconst ITEM_STYLE = {\n  overflowAnchor: \"none\"\n};\nconst Items = /* @__PURE__ */React.memo(function VirtuosoItems2() {\n  const listState = useEmitterValue(\"listState\");\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue(\"itemContent\");\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const {\n    callbackRef,\n    ref\n  } = useChangedListContentsSizes(sizeRanges, itemSize, trackItemSizes, scrollContainerStateCallback, log, void 0, customScrollParent);\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", value => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */React.createElement(FillerRow, {\n    height: paddingTop,\n    key: \"padding-top\",\n    context\n  }) : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */React.createElement(FillerRow, {\n    height: paddingBottom,\n    key: \"padding-bottom\",\n    context\n  }) : null;\n  const items = listState.items.map(item => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\"\n      });\n    }\n    return React.createElement(TableRowComponent, {\n      ...contextPropIfNotDomElement(TableRowComponent, context),\n      key,\n      \"data-index\": index,\n      \"data-known-size\": item.size,\n      \"data-item-index\": item.index,\n      item: item.data,\n      style: ITEM_STYLE\n    }, itemContent(item.index, item.data, context));\n  });\n  return React.createElement(TableBodyComponent, {\n    ref: callbackRef,\n    \"data-test-id\": \"virtuoso-item-list\",\n    ...contextPropIfNotDomElement(TableBodyComponent, context)\n  }, [paddingTopEl, ...items, paddingBottomEl]);\n});\nconst Viewport = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, el => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    style: viewportStyle,\n    ref: viewportRef,\n    \"data-viewport-type\": \"element\"\n  }, children);\n};\nconst WindowViewport = ({\n  children\n}) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({\n        offsetTop: 0,\n        visibleHeight: ctx.viewportHeight,\n        visibleWidth: 100\n      });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */React.createElement(\"div\", {\n    ref: viewportRef,\n    style: viewportStyle,\n    \"data-viewport-type\": \"window\"\n  }, children);\n};\nconst TableRoot = /* @__PURE__ */React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(compose(fixedHeaderHeight, el => correctItemSize(el, \"height\")));\n  const tfootRef = useSize(compose(fixedFooterHeight, el => correctItemSize(el, \"height\")));\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? React.createElement(TheTHead, {\n    key: \"TableHead\",\n    style: {\n      zIndex: 2,\n      position: \"sticky\",\n      top: 0\n    },\n    ref: theadRef,\n    ...contextPropIfNotDomElement(TheTHead, context)\n  }, fixedHeaderContent()) : null;\n  const theFoot = fixedFooterContent ? React.createElement(TheTFoot, {\n    key: \"TableFoot\",\n    style: {\n      zIndex: 1,\n      position: \"sticky\",\n      bottom: 0\n    },\n    ref: tfootRef,\n    ...contextPropIfNotDomElement(TheTFoot, context)\n  }, fixedFooterContent()) : null;\n  return /* @__PURE__ */React.createElement(TheScroller, {\n    ...props\n  }, /* @__PURE__ */React.createElement(TheViewport, null, React.createElement(TheTable, {\n    style: {\n      borderSpacing: 0,\n      overflowAnchor: \"none\"\n    },\n    ...contextPropIfNotDomElement(TheTable, context)\n  }, [theHead, /* @__PURE__ */React.createElement(Items, {\n    key: \"TableBody\"\n  }), theFoot])));\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */systemToComponent(combinedSystem, {\n  required: {},\n  optional: {\n    context: \"context\",\n    followOutput: \"followOutput\",\n    firstItemIndex: \"firstItemIndex\",\n    itemContent: \"itemContent\",\n    fixedHeaderContent: \"fixedHeaderContent\",\n    fixedFooterContent: \"fixedFooterContent\",\n    overscan: \"overscan\",\n    increaseViewportBy: \"increaseViewportBy\",\n    totalCount: \"totalCount\",\n    topItemCount: \"topItemCount\",\n    initialTopMostItemIndex: \"initialTopMostItemIndex\",\n    components: \"components\",\n    groupCounts: \"groupCounts\",\n    atBottomThreshold: \"atBottomThreshold\",\n    atTopThreshold: \"atTopThreshold\",\n    computeItemKey: \"computeItemKey\",\n    defaultItemHeight: \"defaultItemHeight\",\n    fixedItemHeight: \"fixedItemHeight\",\n    itemSize: \"itemSize\",\n    scrollSeekConfiguration: \"scrollSeekConfiguration\",\n    data: \"data\",\n    initialItemCount: \"initialItemCount\",\n    initialScrollTop: \"initialScrollTop\",\n    alignToBottom: \"alignToBottom\",\n    useWindowScroll: \"useWindowScroll\",\n    customScrollParent: \"customScrollParent\",\n    scrollerRef: \"scrollerRef\",\n    logLevel: \"logLevel\"\n  },\n  methods: {\n    scrollToIndex: \"scrollToIndex\",\n    scrollIntoView: \"scrollIntoView\",\n    scrollTo: \"scrollTo\",\n    scrollBy: \"scrollBy\"\n  },\n  events: {\n    isScrolling: \"isScrolling\",\n    endReached: \"endReached\",\n    startReached: \"startReached\",\n    rangeChanged: \"rangeChanged\",\n    atBottomStateChange: \"atBottomStateChange\",\n    atTopStateChange: \"atTopStateChange\",\n    totalListHeightChanged: \"totalListHeightChanged\",\n    itemsRendered: \"itemsRendered\",\n    groupIndices: \"groupIndices\"\n  }\n}, TableRoot);\nconst Scroller = /* @__PURE__ */buildScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst WindowScroller = /* @__PURE__ */buildWindowScroller({\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n});\nconst TableVirtuoso = Table;\nexport { GroupedVirtuoso, LogLevel, TableVirtuoso, Virtuoso, VirtuosoGrid, VirtuosoGridMockContext, VirtuosoMockContext };","map":{"version":3,"names":["React","ReactDOM","PUBLISH","SUBSCRIBE","RESET","VALUE","compose","a","b","arg","thrush","proc","curry2to1","arg1","arg2","curry1to0","tap","tup","args","call","always","value","joinProc","procs","map","isDefined","noop","subscribe","emitter","subscription","publish","publisher","reset","getValue","depot","connect","handleNext","unsub","stream","subscriptions","action","splice","length","push","indexOf","slice","forEach","Error","statefulStream","initial","innerSubject","eventHandler","currentSubscription","cleanup","streamFromEmitter","stream2","statefulStreamFromEmitter","combineOperators","operators","subscriber","reduceRight","pipe","source","project","defaultComparator","previous","next","distinctUntilChanged","comparator","current","done","filter","predicate","mapTo","scan","scanner","skip","times","throttleTime","interval","currentValue","timeout","setTimeout","debounceTime","clearTimeout","withLatestFrom","sources","values","Array","called","pendingCall","allCalled","Math","pow","index","bit","prevCalled","call2","concat","merge","duc","combineLatest","emitters","system","constructor","dependencies","singleton","id","Symbol","init","systemSpec","singletons","Map","_init","id2","has","get","system2","e","set","omit","keys","obj","result","idx","len","prop","hasOwnProperty","useIsomorphicLayoutEffect$2","document","useLayoutEffect","useEffect","systemToComponent","map2","Root","requiredPropNames","Object","required","optionalPropNames","optional","methodNames","methods","eventNames","events","Context","createContext","applyPropsToSystem","props","requiredPropName","optionalPropName","buildMethods","reduce","acc","methodName","buildEventHandlers","handlers","eventName","Component","forwardRef","propsWithChildren","ref","children","useState","system22","useImperativeHandle","createElement","Provider","usePublisher2","key","useCallback","useContext","useEmitterValue2","setValue","useEmitter2","callback","context","usePublisher","useEmitterValue","useEmitter","useIsomorphicLayoutEffect","useIsomorphicLayoutEffect$1","LogLevel","LogLevel2","CONSOLE_METHOD_MAP","getGlobalThis","globalThis","window","loggerSystem","logLevel","log","label","message","level","_a","currentLevel","console","useSizeWithElRef","enabled","useRef","callbackRef","_el","ResizeObserver","observer","useMemo","entries","element","target","offsetParent","elRef","observe","unobserve","useSize","useChangedListContentsSizes","itemSize","scrollContainerStateCallback","gap","customScrollParent","memoedCallback","el","ranges","getChangedChildSizes","scrollableElement","parentElement","dataset","windowScrolling","lastElementChild","scrollTop","pageYOffset","documentElement","scrollHeight","viewportHeight","offsetHeight","innerHeight","max","resolveGapValue$1","getComputedStyle","rowGap","field","results","i","child","item","parseInt","knownSize","parseFloat","size","ERROR","lastResult","endIndex","startIndex","property","endsWith","WARN","correctItemSize","dimension","round","getBoundingClientRect","approximatelyEqual","num1","num2","abs","useScrollTop","smoothScrollTargetReached","scrollerElement","scrollerRefCallback","scrollerRef","scrollTopTarget","timeoutRef","handler","ev","windowScroll","suppressFlushSync","flushSync","localRef","addEventListener","passive","removeEventListener","scrollToCallback","location","scrollerElement2","isSmooth","behavior","maxScrollTop","top","ceil","min","scrollTo","scrollByCallback","scrollBy","domIOSystem","scrollContainerState","deviation","statefulScrollTop","headerHeight","fixedHeaderHeight","fixedFooterHeight","footerHeight","scrollingInProgress","scrollTop2","scrollHeight2","NIL_NODE","lvl","newAANode","k","v","l","r","empty","node","newTree","remove","lastKey","lastValue","last","adjust","clone","deleteLast","find","findMaxKeyValue","Infinity","Number","insert","rebalance","walkWithin","start","end","walk","isSingle","split","skew","rl","rlvl","rangesWithin","adjustedStart","toRanges","arrayToRanges","items","parser","nextIndex","nextValue","nodes","findIndexOfClosestSmallerOrEqual","floor","match","join","findClosestSmallerOrEqual","findRange","startValue","endValue","recalcSystem","recalcInProgress","rangeIncludes","refRange","range","affectedGroupCount","offset","groupIndices","recognizedOffsetItems","groupIndex","offsetIsExact","insertRanges","sizeTree","syncStart","overlappingRanges","some","firstPassDone","shouldInsert","rangeStart","rangeEnd","rangeValue","initialSizeState","offsetTree","groupOffsetTree","lastIndex","lastOffset","lastSize","indexComparator","itemIndex","offsetComparator","itemOffset","offsetPointParser","point","rangesWithinOffsets","tree","startOffset","endOffset","minStartIndex","createOffsetTree","prevOffsetTree","prevIndex","prevSize","prevOffset","offsetInfo","kv","startIndex2","indexOffset","aOffset","sizeStateReducer","state","DEBUG","newSizeTree","groupSize","newOffsetTree","offsetOf","itemCount","isGroupLocation","originalIndexFromLocation","sizes","numericIndex","originalIndexFromItemIndex","hasGroups","groupOffset","sizeTreeToRanges","sizeArray","nextSize","SIZE_MAP","offsetWidth","sizeSystem","sizeRanges","totalCount","statefulTotalCount","unshiftWith","shiftWith","firstItemIndex","fixedItemSize","defaultItemSize","data","prevGroupIndices","prev","curr","indexes","groupIndices2","sizes2","gap2","totalCount2","trackItemSizes","listRefresh","oldSizes","_","newSizes","changed","diff","val","prevGroupIndicesValue","log2","beforeUnshiftWith","unshiftWith2","groupedMode","initialRanges","defaultSize","firstGroupSize","prependedGroupItemsCount","theGroupIndex","groupItemCount","sizeTreeKV","firstGroupIsExpanded","shift","shiftWithOffset","shiftWith2","newFirstItemIndex","removedItemsCount","aGroupIsShrunk","nextItemSize","SUPPORTS_SCROLL_TO_OPTIONS","style","normalizeIndexLocation","align","scrollToIndexSystem","scrollToIndex","topListHeight","unsubscribeNextListRefresh","cleartTimeoutRef","unsubscribeListRefresh","viewportHeight2","topListHeight2","headerHeight2","footerHeight2","fixedHeaderHeight2","fixedFooterHeight2","normalLocation","retry","listChanged","watchChangesFor","limit","UP","DOWN","NONE$1","INITIAL_BOTTOM_STATE","atBottom","notAtBottomBecause","offsetBottom","DEFAULT_AT_TOP_THRESHOLD","stateFlagsSystem","isAtBottom","isAtTop","atBottomStateChange","atTopStateChange","atBottomThreshold","atTopThreshold","isScrolling","isScrollingBy","atTopThreshold2","atBottomState","_headerHeight","_footerHeight","atBottomThreshold2","isAtBottom2","atBottomBecause","scrollTopDelta","lastJumpDueToItemResize","jump","scrollDirection","direction","prevScrollTop","scrollVelocity","isScrolling2","propsReadySystem","propsReady","didMount","ready","skipFrames","frameCount","requestAnimationFrame","getInitialTopMostItemIndexNumber","initialTopMostItemIndexSystem","scrolledToInitialItem","initialTopMostItemIndex","scrollScheduled","didMount2","scrolledToInitialItem2","defaultItemSize2","scrollScheduled2","initialTopMostItemIndex2","normalizeFollowOutput","follow","behaviorFromFollowOutput","followOutputSystem","followOutput","autoscrollToBottom","pendingScrollHandle","scrollToBottom","followOutputBehavior","followOutput2","scrollingInProgress2","shouldFollow","trapNextSizeIncrease","cancel","refreshed","groupCountsToIndicesAndCount","counts","groupCount","groupedListSystem","groupCounts","topItemsIndexes","groupIndicesAndCount","tupleComparator","rangeComparator","TOP","BOTTOM","NONE","getOverscan","overscan","main","reverse","getViewportIncrease","sizeRangeSystem","listBoundary","increaseViewportBy","visibleRange","listTop","listBottom","overscan2","deviation2","increaseViewportBy2","stickyHeaderHeight","headerVisible","topViewportAddition","bottomViewportAddition","probeItemSet","EMPTY_LIST_STATE","topItems","offsetTop","bottom","transposeItems","originalIndex","transposedItems","groupRanges","currentRange","currentGroupIndex","transposedItem","type","buildListState","lastItem","total","height","listStateSystem","groupedListSystem2","rangeTopListHeight","stateFlags","itemsRendered","listState","mount","recalcInProgress2","data2","dataChangeInProgress","topItemsIndexes2","firstItemIndex2","sizesValue","rangeStartIndex","rangeEndIndex","offsetPointRanges","maxIndex","endReached","count","startReached","rangeChanged","initialItemCountSystem","initialItemCount","includedGroupsCount","adjustedCount","from","scrollSeekSystem","isSeeking","scrollSeekConfiguration","config","speed","isSeeking2","exit","enter","velocity","change","scrollSeekRangeChanged","topItemCountSystem","topItemCount","totalListHeightSystem","totalListHeightChanged","totalListHeight","listState2","simpleMemoize","func","isMobileSafari","test","navigator","userAgent","upwardScrollFixSystem","deviationOffset","prevItems","prevTotalCount","prevTotalHeight","lastJumpDueToItemResize2","totalHeight","newDev","atStart","amount","scrollDirection2","scrollByWith","deviationAmount","is","recalc","getItemOffset","defaultGroupSize","initialScrollTopSystem","initialScrollTop","alignToBottomSystem","alignToBottom","paddingTopAddition","totalListHeight2","windowScrollerSystem","windowScrollContainerState","windowViewportRect","windowScrollTo","useWindowScroll","windowScrollTop","scrollTo2","defaultCalculateViewLocation","itemTop","itemTop2","itemBottom","viewportTop","viewportBottom","locationParams","rest","scrollIntoViewSystem","scrollIntoView","viewLocation","calculateViewLocation","actualIndex","stateLoadSystem","getState","restoreStateFrom","locationFromSnapshot","snapshot","featureGroup1System","sizeRange","scrollSeek","initialScrollTopSystem2","windowScroller","logger","listSystem","domIO","stateLoad","flags","featureGroup1","visibleHeight","fixedItemHeight","defaultItemHeight","WEBKIT_STICKY","STICKY","positionStickyCssValue","position","useWindowViewportRectRef","viewportInfo","calculateInfo","rect","visibleWidth","width","customScrollParentRect","deltaTop","scrollAndResizeEventHandler","VirtuosoMockContext","VirtuosoGridMockContext","identity","listComponentPropsSystem","itemContent","groupContent","components","computeItemKey","headerFooterTag","distinctProp","propName","defaultValue","components2","FooterComponent","HeaderComponent","TopItemListComponent","ListComponent","ItemComponent","GroupComponent","ScrollerComponent","EmptyPlaceholder","ScrollSeekPlaceholder","combinedSystem$2","listSystem2","propsSystem","DefaultScrollSeekPlaceholder$1","GROUP_STYLE","zIndex","overflowAnchor","ITEM_STYLE$1","Items$1","memo","VirtuosoItems","showTopList","useEmitterValue$2","usePublisher$2","windowScrollContainerStateCallback","_scrollContainerStateCallback","listGap","setDeviation","useEmitter$2","hasGroups2","containerStyle","boxSizing","paddingTop","paddingBottom","marginTop","visibility","contextPropIfNotDomElement","scrollerStyle","outline","overflowY","WebkitOverflowScrolling","viewportStyle","topItemListStyle","Header$1","VirtuosoHeader","Header2","Footer$1","VirtuosoFooter","Footer2","buildScroller","Scroller2","VirtuosoScroller","tabIndex","buildWindowScroller","VirtuosoWindowScroller","Viewport$2","ctx","viewportRef","itemHeight","WindowViewport$2","TopItemListContainer","TopItemList","ListRoot","VirtuosoRoot","TheScroller","WindowScroller$2","Scroller$2","TheViewport","List","Virtuoso","GroupedVirtuoso","INITIAL_GRID_STATE","itemWidth","PROBE_GRID_STATE","buildProbeGridState","buildItems","dataItem","gapComparator","column","row","dimensionComparator","gridSystem","gridState","viewportDimensions","itemDimensions","stateChanged","stateRestoreInProgress","itemDimensions2","viewportDimensions2","viewport","_value","stateRestoreInProgress2","initialItemCount2","columnGap","viewportWidth","endIndex2","perRow","itemsPerRow","gridLayout","rowCount","hasScrolled","hasScrolled2","gridState2","gridComponentPropsSystem","itemClassName","listClassName","combinedSystem$1","gridSystem2","gridComponentPropsSystem2","GridItems","GridItems2","useEmitterValue$1","scrollHeightCallback","usePublisher$1","gridGap","listRef","firstItem","firstChild","resolveGapValue","className","Header","VirtuosoHeader2","Footer","VirtuosoGridFooter","Viewport$1","WindowViewport$1","GridRoot","GridRoot2","WindowScroller$1","Scroller$1","Grid","useEmitter$1","VirtuosoGrid","tableComponentPropsSystem","fixedHeaderContent","fixedFooterContent","TableComponent","TableHeadComponent","TableFooterComponent","TableBodyComponent","TableRowComponent","FillerRow","combinedSystem","DefaultScrollSeekPlaceholder","DefaultFillerRow","padding","border","ITEM_STYLE","Items","VirtuosoItems2","paddingTopEl","paddingBottomEl","Viewport","WindowViewport","TableRoot","TableVirtuosoRoot","theadRef","tfootRef","WindowScroller","Scroller","TheTable","TheTHead","TheTFoot","theHead","theFoot","borderSpacing","Table","TableVirtuoso"],"sources":["/Users/agnusmariajoseph/Documents/study/misc/sql-query-runner/node_modules/react-virtuoso/dist/index.mjs"],"sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return (arg) => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return (arg2) => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup(...args) {\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc(...procs) {\n  return () => {\n    procs.map(call);\n  };\n}\nfunction isDefined(arg) {\n  return arg !== void 0;\n}\nfunction noop() {\n}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, (value) => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach((subscription) => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), (stream2) => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n  return (subscriber) => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source, ...operators) {\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n  let current;\n  return (done) => (next) => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return (done) => (value) => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return (done) => compose(done, project);\n}\nfunction mapTo(value) {\n  return (done) => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return (done) => (value) => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return (done) => (value) => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue = null;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom(...sources) {\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return (done) => (value) => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge(...sources) {\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map((source) => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source, comparator = defaultComparator) {\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n  const innerSubject = stream();\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor, dependencies = [], { singleton } = { singleton: true }) {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */ new Map();\n  const _init = ({ id: id2, constructor, dependencies, singleton }) => {\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map((e) => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$2 = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = React.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = (value) => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = React.forwardRef((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren;\n    const [system2] = React.useState(() => {\n      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = React.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$2(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$2(() => {\n      applyPropsToSystem(system2, props);\n    });\n    React.useImperativeHandle(ref, always(buildMethods(system2)));\n    return React.createElement(\n      Context.Provider,\n      { value: system2 },\n      Root ? React.createElement(\n        Root,\n        omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n        children\n      ) : children\n    );\n  });\n  const usePublisher2 = (key) => {\n    return React.useCallback(curry2to1(publish, React.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue2 = (key) => {\n    const system2 = React.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = React.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$2(\n      () => subscribe(source, (next) => {\n        if (next !== value) {\n          setValue(always(next));\n        }\n      }),\n      [source, value]\n    );\n    return value;\n  };\n  const useEmitter2 = (key, callback) => {\n    const context = React.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$2(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nconst useIsomorphicLayoutEffect$1 = useIsomorphicLayoutEffect;\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [\n    0\n    /* DEBUG */\n  ]: \"debug\",\n  [\n    1\n    /* INFO */\n  ]: \"log\",\n  [\n    2\n    /* WARN */\n  ]: \"warn\",\n  [\n    3\n    /* ERROR */\n  ]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(\n  () => {\n    const logLevel = statefulStream(\n      3\n      /* ERROR */\n    );\n    const log = statefulStream((label, message, level = 1) => {\n      var _a;\n      const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n      if (level >= currentLevel) {\n        console[CONSOLE_METHOD_MAP[level]](\n          \"%creact-virtuoso: %c%s %o\",\n          \"color: #0253b3; font-weight: bold\",\n          \"color: initial\",\n          label,\n          message\n        );\n      }\n    });\n    return {\n      log,\n      logLevel\n    };\n  },\n  [],\n  { singleton: true }\n);\nfunction useSizeWithElRef(callback, enabled = true) {\n  const ref = React.useRef(null);\n  let callbackRef = (_el) => {\n  };\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = React.useMemo(() => {\n      return new ResizeObserver((entries) => {\n        const element = entries[0].target;\n        if (element.offsetParent !== null) {\n          callback(element);\n        }\n      });\n    }, [callback]);\n    callbackRef = (elRef) => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return { ref, callbackRef };\n}\nfunction useSize(callback, enabled = true) {\n  return useSizeWithElRef(callback, enabled).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent) {\n  const memoedCallback = React.useCallback(\n    (el) => {\n      const ranges = getChangedChildSizes(el.children, itemSize, \"offsetHeight\", log);\n      let scrollableElement = el.parentElement;\n      while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n        scrollableElement = scrollableElement.parentElement;\n      }\n      const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n      const scrollTop = customScrollParent ? customScrollParent.scrollTop : windowScrolling ? window.pageYOffset || document.documentElement.scrollTop : scrollableElement.scrollTop;\n      const scrollHeight = customScrollParent ? customScrollParent.scrollHeight : windowScrolling ? document.documentElement.scrollHeight : scrollableElement.scrollHeight;\n      const viewportHeight = customScrollParent ? customScrollParent.offsetHeight : windowScrolling ? window.innerHeight : scrollableElement.offsetHeight;\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n      gap == null ? void 0 : gap(resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log));\n      if (ranges !== null) {\n        callback(ranges);\n      }\n    },\n    [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]\n  );\n  return useSizeWithElRef(memoedCallback, enabled);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", { child }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({ startIndex: index, endIndex: index, size });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent) {\n  const scrollerRef = React.useRef(null);\n  const scrollTopTarget = React.useRef(null);\n  const timeoutRef = React.useRef(null);\n  const handler = React.useCallback(\n    (ev) => {\n      const el = ev.target;\n      const windowScroll = el === window || el === document;\n      const scrollTop = windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n      const scrollHeight = windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n      const viewportHeight = windowScroll ? window.innerHeight : el.offsetHeight;\n      const call2 = () => {\n        scrollContainerStateCallback({\n          scrollTop: Math.max(scrollTop, 0),\n          scrollHeight,\n          viewportHeight\n        });\n      };\n      if (ev.suppressFlushSync) {\n        call2();\n      } else {\n        ReactDOM.flushSync(call2);\n      }\n      if (scrollTopTarget.current !== null) {\n        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n          scrollTopTarget.current = null;\n          smoothScrollTargetReached(true);\n          if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n          }\n        }\n      }\n    },\n    [scrollContainerStateCallback, smoothScrollTargetReached]\n  );\n  React.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({ target: localRef, suppressFlushSync: true });\n    localRef.addEventListener(\"scroll\", handler, { passive: true });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(correctItemSize(document.documentElement, \"height\"), document.documentElement.scrollHeight);\n      offsetHeight = window.innerHeight;\n      scrollTop = document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2.scrollHeight;\n      offsetHeight = correctItemSize(scrollerElement2, \"height\");\n      scrollTop = scrollerElement2.scrollTop;\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    scrollerRef.current.scrollBy(location);\n  }\n  return { scrollerRef, scrollByCallback, scrollToCallback };\n}\nconst domIOSystem = system(\n  () => {\n    const scrollContainerState = stream();\n    const scrollTop = stream();\n    const deviation = statefulStream(0);\n    const smoothScrollTargetReached = stream();\n    const statefulScrollTop = statefulStream(0);\n    const viewportHeight = stream();\n    const scrollHeight = stream();\n    const headerHeight = statefulStream(0);\n    const fixedHeaderHeight = statefulStream(0);\n    const fixedFooterHeight = statefulStream(0);\n    const footerHeight = statefulStream(0);\n    const scrollTo = stream();\n    const scrollBy = stream();\n    const scrollingInProgress = statefulStream(false);\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollTop: scrollTop2 }) => scrollTop2)\n      ),\n      scrollTop\n    );\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollHeight: scrollHeight2 }) => scrollHeight2)\n      ),\n      scrollHeight\n    );\n    connect(scrollTop, statefulScrollTop);\n    return {\n      // input\n      scrollContainerState,\n      scrollTop,\n      viewportHeight,\n      headerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight,\n      footerHeight,\n      scrollHeight,\n      smoothScrollTargetReached,\n      // signals\n      scrollTo,\n      scrollBy,\n      // state\n      statefulScrollTop,\n      deviation,\n      scrollingInProgress\n    };\n  },\n  [],\n  { singleton: true }\n);\nconst NIL_NODE = { lvl: 0 };\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n  return { k, v, lvl, l, r };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node))\n    return NIL_NODE;\n  const { k, l, r } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, { k: lastKey, v: lastValue, l: deleteLast(l) }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, { l: remove(l, key) }));\n  } else {\n    return adjust(clone(node, { r: remove(r, key) }));\n  }\n}\nfunction find(node, key) {\n  if (empty(node)) {\n    return;\n  }\n  if (key === node.k) {\n    return node.v;\n  } else if (key < node.k) {\n    return find(node.l, key);\n  } else {\n    return find(node.r, key);\n  }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (Number(node[field]) === value) {\n    return [node.k, node.v];\n  }\n  if (Number(node[field]) < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, { k, v });\n  } else if (k < node.k) {\n    return rebalance(clone(node, { l: insert(node.l, k, v) }));\n  } else {\n    return rebalance(clone(node, { r: insert(node.r, k, v) }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const { k, v, l, r } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({ k, v });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, { r: deleteLast(node.r) }));\n}\nfunction clone(node, args) {\n  return newAANode(\n    args.k !== void 0 ? args.k : node.k,\n    args.v !== void 0 ? args.v : node.v,\n    args.lvl !== void 0 ? args.lvl : node.lvl,\n    args.l !== void 0 ? args.l : node.l,\n    args.r !== void 0 ? args.r : node.r\n  );\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const { l, r, lvl } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, { r: l.r.l }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, { l: rl.r, lvl: rlvl })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let { index: start, value } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const { index: nextIndex, value: nextValue } = parser(items[i]);\n    result.push({ start, end: nextIndex - 1, value });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({ start, end: Infinity, value });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, ({ k: index, v: value }) => ({ index, value }));\n}\nfunction split(node) {\n  const { r, lvl } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, { l: clone(node, { r: r.l }), lvl: lvl + 1 }) : node;\n}\nfunction skew(node) {\n  const { l } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, { r: clone(node, { l: l.r }) }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(\n  () => {\n    const recalcInProgress = statefulStream(false);\n    return { recalcInProgress };\n  },\n  [],\n  { singleton: true }\n);\nfunction rangeIncludes(refRange) {\n  const { size, startIndex, endIndex } = refRange;\n  return (range) => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n  let recognizedOffsetItems = 0;\n  let groupIndex = 0;\n  while (recognizedOffsetItems < offset) {\n    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n    groupIndex++;\n  }\n  const offsetIsExact = recognizedOffsetItems === offset;\n  return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const { size, startIndex, endIndex } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator({ index: itemIndex }, index) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({ offset: itemOffset }, offset) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return { index: point.index, value: point };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const { offset, index: startIndex, size } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n  return walk(sizeTree).map(({ k: startIndex, v: size }, index, sizeArray) => {\n    const nextSize = sizeArray[index + 1];\n    const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n    return { startIndex, endIndex, size };\n  });\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(\n  ([{ log }, { recalcInProgress }]) => {\n    const sizeRanges = stream();\n    const totalCount = stream();\n    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n    const unshiftWith = stream();\n    const shiftWith = stream();\n    const firstItemIndex = statefulStream(0);\n    const groupIndices = statefulStream([]);\n    const fixedItemSize = statefulStream(void 0);\n    const defaultItemSize = statefulStream(void 0);\n    const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n    const data = statefulStream(void 0);\n    const gap = statefulStream(0);\n    const initial = initialSizeState();\n    const sizes = statefulStreamFromEmitter(\n      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()),\n      initial\n    );\n    const prevGroupIndices = statefulStreamFromEmitter(\n      pipe(\n        groupIndices,\n        distinctUntilChanged(),\n        scan((prev, curr) => ({ prev: prev.current, current: curr }), {\n          prev: [],\n          current: []\n        }),\n        map(({ prev }) => prev)\n      ),\n      []\n    );\n    connect(\n      pipe(\n        groupIndices,\n        filter((indexes) => indexes.length > 0),\n        withLatestFrom(sizes, gap),\n        map(([groupIndices2, sizes2, gap2]) => {\n          const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n            return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n          }, newTree());\n          return {\n            ...sizes2,\n            groupIndices: groupIndices2,\n            groupOffsetTree\n          };\n        })\n      ),\n      sizes\n    );\n    connect(\n      pipe(\n        totalCount,\n        withLatestFrom(sizes),\n        filter(([totalCount2, { lastIndex }]) => {\n          return totalCount2 < lastIndex;\n        }),\n        map(([totalCount2, { lastIndex, lastSize }]) => {\n          return [\n            {\n              startIndex: totalCount2,\n              endIndex: lastIndex,\n              size: lastSize\n            }\n          ];\n        })\n      ),\n      sizeRanges\n    );\n    connect(fixedItemSize, defaultItemSize);\n    const trackItemSizes = statefulStreamFromEmitter(\n      pipe(\n        fixedItemSize,\n        map((size) => size === void 0)\n      ),\n      true\n    );\n    connect(\n      pipe(\n        defaultItemSize,\n        filter((value) => {\n          return value !== void 0 && empty(getValue(sizes).sizeTree);\n        }),\n        map((size) => [{ startIndex: 0, endIndex: 0, size }])\n      ),\n      sizeRanges\n    );\n    const listRefresh = streamFromEmitter(\n      pipe(\n        sizeRanges,\n        withLatestFrom(sizes),\n        scan(\n          ({ sizes: oldSizes }, [_, newSizes]) => {\n            return {\n              changed: newSizes !== oldSizes,\n              sizes: newSizes\n            };\n          },\n          { changed: false, sizes: initial }\n        ),\n        map((value) => value.changed)\n      )\n    );\n    subscribe(\n      pipe(\n        firstItemIndex,\n        scan(\n          (prev, next) => {\n            return { diff: prev.prev - next, prev: next };\n          },\n          { diff: 0, prev: 0 }\n        ),\n        map((val) => val.diff)\n      ),\n      (offset) => {\n        const { groupIndices: groupIndices2 } = getValue(sizes);\n        if (offset > 0) {\n          publish(recalcInProgress, true);\n          publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n        } else if (offset < 0) {\n          const prevGroupIndicesValue = getValue(prevGroupIndices);\n          if (prevGroupIndicesValue.length > 0) {\n            offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n          }\n          publish(shiftWith, offset);\n        }\n      }\n    );\n    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {\n      if (index < 0) {\n        log2(\n          \"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\",\n          { firstItemIndex },\n          LogLevel.ERROR\n        );\n      }\n    });\n    const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n    connect(\n      pipe(\n        unshiftWith,\n        withLatestFrom(sizes),\n        map(([unshiftWith2, sizes2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          const initialRanges = [];\n          const defaultSize = sizes2.lastSize;\n          if (groupedMode) {\n            const firstGroupSize = find(sizes2.sizeTree, 0);\n            let prependedGroupItemsCount = 0;\n            let groupIndex = 0;\n            while (prependedGroupItemsCount < unshiftWith2) {\n              const theGroupIndex = sizes2.groupIndices[groupIndex];\n              const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n              initialRanges.push({\n                startIndex: theGroupIndex,\n                endIndex: theGroupIndex,\n                size: firstGroupSize\n              });\n              initialRanges.push({\n                startIndex: theGroupIndex + 1,\n                endIndex: theGroupIndex + 1 + groupItemCount - 1,\n                size: defaultSize\n              });\n              groupIndex++;\n              prependedGroupItemsCount += groupItemCount + 1;\n            }\n            const sizeTreeKV = walk(sizes2.sizeTree);\n            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n            if (firstGroupIsExpanded) {\n              sizeTreeKV.shift();\n            }\n            return sizeTreeKV.reduce(\n              (acc, { k: index, v: size }) => {\n                let ranges = acc.ranges;\n                if (acc.prevSize !== 0) {\n                  ranges = [\n                    ...acc.ranges,\n                    {\n                      startIndex: acc.prevIndex,\n                      endIndex: index + unshiftWith2 - 1,\n                      size: acc.prevSize\n                    }\n                  ];\n                }\n                return {\n                  ranges,\n                  prevIndex: index + unshiftWith2,\n                  prevSize: size\n                };\n              },\n              {\n                ranges: initialRanges,\n                prevIndex: unshiftWith2,\n                prevSize: 0\n              }\n            ).ranges;\n          }\n          return walk(sizes2.sizeTree).reduce(\n            (acc, { k: index, v: size }) => {\n              return {\n                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index + unshiftWith2 - 1, size: acc.prevSize }],\n                prevIndex: index + unshiftWith2,\n                prevSize: size\n              };\n            },\n            {\n              ranges: [],\n              prevIndex: 0,\n              prevSize: defaultSize\n            }\n          ).ranges;\n        })\n      ),\n      sizeRanges\n    );\n    const shiftWithOffset = streamFromEmitter(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, { offsetTree }, gap2]) => {\n          const newFirstItemIndex = -shiftWith2;\n          return offsetOf(newFirstItemIndex, offsetTree, gap2);\n        })\n      )\n    );\n    connect(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, sizes2, gap2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          if (groupedMode) {\n            if (empty(sizes2.sizeTree)) {\n              return sizes2;\n            }\n            let newSizeTree = newTree();\n            const prevGroupIndicesValue = getValue(prevGroupIndices);\n            let removedItemsCount = 0;\n            let groupIndex = 0;\n            let groupOffset = 0;\n            while (removedItemsCount < -shiftWith2) {\n              groupOffset = prevGroupIndicesValue[groupIndex];\n              const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n              groupIndex++;\n              removedItemsCount += groupItemCount + 1;\n            }\n            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newSizeTree);\n            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n            if (aGroupIsShrunk) {\n              const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n              newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n              const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n              newSizeTree = insert(newSizeTree, 1, nextItemSize);\n            }\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          } else {\n            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newTree());\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          }\n        })\n      ),\n      sizes\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      sizeRanges,\n      groupIndices,\n      defaultItemSize,\n      fixedItemSize,\n      unshiftWith,\n      shiftWith,\n      shiftWithOffset,\n      beforeUnshiftWith,\n      firstItemIndex,\n      gap,\n      // output\n      sizes,\n      listRefresh,\n      statefulTotalCount,\n      trackItemSizes,\n      itemSize\n    };\n  },\n  tup(loggerSystem, recalcSystem),\n  { singleton: true }\n);\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? { index: location } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(\n  ([\n    { sizes, totalCount, listRefresh, gap },\n    {\n      scrollingInProgress,\n      viewportHeight,\n      scrollTo,\n      smoothScrollTargetReached,\n      headerHeight,\n      footerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight\n    },\n    { log }\n  ]) => {\n    const scrollToIndex = stream();\n    const topListHeight = statefulStream(0);\n    let unsubscribeNextListRefresh = null;\n    let cleartTimeoutRef = null;\n    let unsubscribeListRefresh = null;\n    function cleanup() {\n      if (unsubscribeNextListRefresh) {\n        unsubscribeNextListRefresh();\n        unsubscribeNextListRefresh = null;\n      }\n      if (unsubscribeListRefresh) {\n        unsubscribeListRefresh();\n        unsubscribeListRefresh = null;\n      }\n      if (cleartTimeoutRef) {\n        clearTimeout(cleartTimeoutRef);\n        cleartTimeoutRef = null;\n      }\n      publish(scrollingInProgress, false);\n    }\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),\n        withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight),\n        map(\n          ([\n            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],\n            gap2,\n            fixedHeaderHeight2,\n            fixedFooterHeight2\n          ]) => {\n            const normalLocation = normalizeIndexLocation(location);\n            const { align, behavior, offset } = normalLocation;\n            const lastIndex = totalCount2 - 1;\n            const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n            let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n            if (align === \"end\") {\n              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n              if (index === lastIndex) {\n                top += footerHeight2;\n              }\n            } else if (align === \"center\") {\n              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n            } else {\n              top -= topListHeight2;\n            }\n            if (offset) {\n              top += offset;\n            }\n            const retry = (listChanged) => {\n              cleanup();\n              if (listChanged) {\n                log2(\"retrying to scroll to\", { location }, LogLevel.DEBUG);\n                publish(scrollToIndex, location);\n              } else {\n                log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n              }\n            };\n            cleanup();\n            if (behavior === \"smooth\") {\n              let listChanged = false;\n              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {\n                listChanged = listChanged || changed;\n              });\n              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n                retry(listChanged);\n              });\n            } else {\n              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n            }\n            cleartTimeoutRef = setTimeout(() => {\n              cleanup();\n            }, 1200);\n            publish(scrollingInProgress, true);\n            log2(\"scrolling from index to\", { index, top, behavior }, LogLevel.DEBUG);\n            return { top, behavior };\n          }\n        )\n      ),\n      scrollTo\n    );\n    return {\n      scrollToIndex,\n      topListHeight\n    };\n  },\n  tup(sizeSystem, domIOSystem, loggerSystem),\n  { singleton: true }\n);\nfunction watchChangesFor(limit) {\n  return (done) => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return (value) => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(\n    pipe(\n      merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),\n      distinctUntilChanged()\n    ),\n    false\n  );\n  const isScrollingBy = statefulStreamFromEmitter(\n    pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),\n    false\n  );\n  connect(\n    pipe(\n      combineLatest(duc(scrollTop), duc(atTopThreshold)),\n      map(([top, atTopThreshold2]) => top <= atTopThreshold2),\n      distinctUntilChanged()\n    ),\n    isAtTop\n  );\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(\n    pipe(\n      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),\n      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {\n        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n        const state = {\n          viewportHeight: viewportHeight2,\n          scrollTop: scrollTop2,\n          scrollHeight\n        };\n        if (isAtBottom2) {\n          let atBottomBecause;\n          let scrollTopDelta;\n          if (scrollTop2 > current.state.scrollTop) {\n            atBottomBecause = \"SCROLLED_DOWN\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2;\n          } else {\n            atBottomBecause = \"SIZE_DECREASED\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n          }\n          return {\n            atBottom: true,\n            state,\n            atBottomBecause,\n            scrollTopDelta\n          };\n        }\n        let notAtBottomBecause;\n        if (state.scrollHeight > current.state.scrollHeight) {\n          notAtBottomBecause = \"SIZE_INCREASED\";\n        } else if (viewportHeight2 < current.state.viewportHeight) {\n          notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n        } else if (scrollTop2 < current.state.scrollTop) {\n          notAtBottomBecause = \"SCROLLING_UPWARDS\";\n        } else {\n          notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n        }\n        return {\n          atBottom: false,\n          notAtBottomBecause,\n          state\n        };\n      }, INITIAL_BOTTOM_STATE),\n      distinctUntilChanged((prev, next) => {\n        return prev && prev.atBottom === next.atBottom;\n      })\n    )\n  );\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(\n    pipe(\n      scrollContainerState,\n      scan(\n        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {\n          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n            if (current.scrollTop !== scrollTop2 && atBottom) {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: current.scrollTop - scrollTop2,\n                changed: true\n              };\n            } else {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: 0,\n                changed: true\n              };\n            }\n          } else {\n            return {\n              scrollTop: scrollTop2,\n              scrollHeight,\n              jump: 0,\n              changed: false\n            };\n          }\n        },\n        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }\n      ),\n      filter((value) => value.changed),\n      map((value) => value.jump)\n    ),\n    0\n  );\n  connect(\n    pipe(\n      atBottomState,\n      map((state) => state.atBottom)\n    ),\n    isAtBottom\n  );\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(\n    pipe(\n      scrollContainerState,\n      map(({ scrollTop: scrollTop2 }) => scrollTop2),\n      distinctUntilChanged(),\n      scan(\n        (acc, scrollTop2) => {\n          if (getValue(isScrollingBy)) {\n            return { direction: acc.direction, prevScrollTop: scrollTop2 };\n          }\n          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };\n        },\n        { direction: DOWN, prevScrollTop: 0 }\n      ),\n      map((value) => value.direction)\n    ),\n    scrollDirection\n  );\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(\n    pipe(\n      isScrolling,\n      filter((value) => !value),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      mapTo(0)\n    ),\n    scrollVelocity\n  );\n  connect(\n    pipe(\n      scrollTop,\n      throttleTime(100),\n      withLatestFrom(isScrolling),\n      filter(([_, isScrolling2]) => !!isScrolling2),\n      scan(([_, prev], [next]) => [prev, next], [0, 0]),\n      map(([prev, next]) => next - prev)\n    ),\n    scrollVelocity\n  );\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(\n  ([{ log }]) => {\n    const propsReady = statefulStream(false);\n    const didMount = streamFromEmitter(\n      pipe(\n        propsReady,\n        filter((ready) => ready),\n        distinctUntilChanged()\n      )\n    );\n    subscribe(propsReady, (value) => {\n      value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n    });\n    return { propsReady, didMount };\n  },\n  tup(loggerSystem),\n  { singleton: true }\n);\nfunction skipFrames(frameCount, callback) {\n  if (frameCount == 0) {\n    callback();\n  } else {\n    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));\n  }\n}\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nconst initialTopMostItemIndexSystem = system(\n  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex }, { didMount }]) => {\n    const scrolledToInitialItem = statefulStream(true);\n    const initialTopMostItemIndex = statefulStream(0);\n    const scrollScheduled = statefulStream(false);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location),\n        mapTo(false)\n      ),\n      scrolledToInitialItem\n    );\n    subscribe(\n      pipe(\n        combineLatest(listRefresh, didMount),\n        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, scrollScheduled),\n        filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled2]) => {\n          return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled2;\n        }),\n        withLatestFrom(initialTopMostItemIndex)\n      ),\n      ([, initialTopMostItemIndex2]) => {\n        publish(scrollScheduled, true);\n        skipFrames(3, () => {\n          handleNext(scrollTop, () => publish(scrolledToInitialItem, true));\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n      }\n    );\n    return {\n      scrolledToInitialItem,\n      initialTopMostItemIndex\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),\n  { singleton: true }\n);\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(\n  ([\n    { totalCount, listRefresh },\n    { isAtBottom, atBottomState },\n    { scrollToIndex },\n    { scrolledToInitialItem },\n    { propsReady, didMount },\n    { log },\n    { scrollingInProgress }\n  ]) => {\n    const followOutput = statefulStream(false);\n    const autoscrollToBottom = stream();\n    let pendingScrollHandle = null;\n    function scrollToBottom(followOutputBehavior) {\n      publish(scrollToIndex, {\n        index: \"LAST\",\n        align: \"end\",\n        behavior: followOutputBehavior\n      });\n    }\n    subscribe(\n      pipe(\n        combineLatest(pipe(duc(totalCount), skip(1)), didMount),\n        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),\n        map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {\n          let shouldFollow = didMount2 && scrolledToInitialItem2;\n          let followOutputBehavior = \"auto\";\n          if (shouldFollow) {\n            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n            shouldFollow = shouldFollow && !!followOutputBehavior;\n          }\n          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };\n        }),\n        filter(({ shouldFollow }) => shouldFollow)\n      ),\n      ({ totalCount: totalCount2, followOutputBehavior }) => {\n        if (pendingScrollHandle) {\n          pendingScrollHandle();\n          pendingScrollHandle = null;\n        }\n        pendingScrollHandle = handleNext(listRefresh, () => {\n          getValue(log)(\"following output to \", { totalCount: totalCount2 }, LogLevel.DEBUG);\n          scrollToBottom(followOutputBehavior);\n          pendingScrollHandle = null;\n        });\n      }\n    );\n    function trapNextSizeIncrease(followOutput2) {\n      const cancel = handleNext(atBottomState, (state) => {\n        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n          getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n          scrollToBottom(\"auto\");\n        }\n      });\n      setTimeout(cancel, 100);\n    }\n    subscribe(\n      pipe(\n        combineLatest(duc(followOutput), totalCount, propsReady),\n        filter(([follow, , ready]) => follow && ready),\n        scan(\n          ({ value }, [, next]) => {\n            return { refreshed: value === next, value: next };\n          },\n          { refreshed: false, value: 0 }\n        ),\n        filter(({ refreshed }) => refreshed),\n        withLatestFrom(followOutput, totalCount)\n      ),\n      ([, followOutput2]) => {\n        trapNextSizeIncrease(followOutput2 !== false);\n      }\n    );\n    subscribe(autoscrollToBottom, () => {\n      trapNextSizeIncrease(getValue(followOutput) !== false);\n    });\n    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n        scrollToBottom(\"auto\");\n      }\n    });\n    return { followOutput, autoscrollToBottom };\n  },\n  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)\n);\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce(\n    (acc, groupCount) => {\n      acc.groupIndices.push(acc.totalCount);\n      acc.totalCount += groupCount + 1;\n      return acc;\n    },\n    {\n      totalCount: 0,\n      groupIndices: []\n    }\n  );\n}\nconst groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.totalCount)\n    ),\n    totalCount\n  );\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.groupIndices)\n    ),\n    groupIndices\n  );\n  connect(\n    pipe(\n      combineLatest(scrollTop, sizes, headerHeight),\n      filter(([_, sizes2]) => hasGroups(sizes2)),\n      map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]),\n      distinctUntilChanged(),\n      map((index) => [index])\n    ),\n    topItemsIndexes\n  );\n  return { groupCounts, topItemsIndexes };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(\n  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {\n    const listBoundary = stream();\n    const topListHeight = statefulStream(0);\n    const increaseViewportBy = statefulStream(0);\n    const overscan = statefulStream(0);\n    const visibleRange = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          duc(scrollTop),\n          duc(viewportHeight),\n          duc(headerHeight),\n          duc(listBoundary, tupleComparator),\n          duc(overscan),\n          duc(topListHeight),\n          duc(fixedHeaderHeight),\n          duc(deviation),\n          duc(increaseViewportBy)\n        ),\n        map(\n          ([\n            scrollTop2,\n            viewportHeight2,\n            headerHeight2,\n            [listTop, listBottom],\n            overscan2,\n            topListHeight2,\n            fixedHeaderHeight2,\n            deviation2,\n            increaseViewportBy2\n          ]) => {\n            const top = scrollTop2 - deviation2;\n            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n            const headerVisible = Math.max(headerHeight2 - top, 0);\n            let direction = NONE;\n            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n            listTop -= deviation2;\n            listTop += headerHeight2 + fixedHeaderHeight2;\n            listBottom += headerHeight2 + fixedHeaderHeight2;\n            listBottom -= deviation2;\n            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n              direction = UP;\n            }\n            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n              direction = DOWN;\n            }\n            if (direction !== NONE) {\n              return [\n                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),\n                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition\n              ];\n            }\n            return null;\n          }\n        ),\n        filter((value) => value != null),\n        distinctUntilChanged(tupleComparator)\n      ),\n      [0, 0]\n    );\n    return {\n      // input\n      listBoundary,\n      overscan,\n      topListHeight,\n      increaseViewportBy,\n      // output\n      visibleRange\n    };\n  },\n  tup(domIOSystem),\n  { singleton: true }\n);\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [\n      { index: groupIndex, size: 0, offset: 0 },\n      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }\n    ];\n  }\n  return [{ index, size: 0, offset: 0, data: data && data[0] }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const { lastSize, lastOffset, lastIndex } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nconst listStateSystem = system(\n  ([\n    { sizes, totalCount, data, firstItemIndex, gap },\n    groupedListSystem2,\n    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },\n    { scrolledToInitialItem, initialTopMostItemIndex },\n    { topListHeight },\n    stateFlags,\n    { didMount },\n    { recalcInProgress }\n  ]) => {\n    const topItemsIndexes = statefulStream([]);\n    const itemsRendered = stream();\n    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n    const listState = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          didMount,\n          recalcInProgress,\n          duc(visibleRange, tupleComparator),\n          duc(totalCount),\n          duc(sizes),\n          duc(initialTopMostItemIndex),\n          scrolledToInitialItem,\n          duc(topItemsIndexes),\n          duc(firstItemIndex),\n          duc(gap),\n          data\n        ),\n        filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {\n          const dataChangeInProgress = data2 && data2.length !== totalCount2;\n          return mount && !recalcInProgress2 && !dataChangeInProgress;\n        }),\n        map(\n          ([\n            ,\n            ,\n            [startOffset, endOffset],\n            totalCount2,\n            sizes2,\n            initialTopMostItemIndex2,\n            scrolledToInitialItem2,\n            topItemsIndexes2,\n            firstItemIndex2,\n            gap2,\n            data2\n          ]) => {\n            const sizesValue = sizes2;\n            const { sizeTree, offsetTree } = sizesValue;\n            if (totalCount2 === 0 || startOffset === 0 && endOffset === 0) {\n              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };\n            }\n            if (empty(sizeTree)) {\n              return buildListState(\n                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),\n                [],\n                totalCount2,\n                gap2,\n                sizesValue,\n                firstItemIndex2\n              );\n            }\n            const topItems = [];\n            if (topItemsIndexes2.length > 0) {\n              const startIndex = topItemsIndexes2[0];\n              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n              let offset = 0;\n              for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n                const size = range.value;\n                const rangeStartIndex = Math.max(range.start, startIndex);\n                const rangeEndIndex = Math.min(range.end, endIndex);\n                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n                  topItems.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size;\n                }\n              }\n            }\n            if (!scrolledToInitialItem2) {\n              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n            }\n            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n            if (offsetPointRanges.length === 0) {\n              return null;\n            }\n            const maxIndex = totalCount2 - 1;\n            const items = tap([], (result) => {\n              for (const range of offsetPointRanges) {\n                const point = range.value;\n                let offset = point.offset;\n                let rangeStartIndex = range.start;\n                const size = point.size;\n                if (point.offset < startOffset) {\n                  rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n                  const itemCount = rangeStartIndex - range.start;\n                  offset += itemCount * size + itemCount * gap2;\n                }\n                if (rangeStartIndex < minStartIndex) {\n                  offset += (minStartIndex - rangeStartIndex) * size;\n                  rangeStartIndex = minStartIndex;\n                }\n                const endIndex = Math.min(range.end, maxIndex);\n                for (let i = rangeStartIndex; i <= endIndex; i++) {\n                  if (offset >= endOffset) {\n                    break;\n                  }\n                  result.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size + gap2;\n                }\n              }\n            });\n            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n          }\n        ),\n        //@ts-expect-error filter needs to be fixed\n        filter((value) => value !== null),\n        distinctUntilChanged()\n      ),\n      EMPTY_LIST_STATE\n    );\n    connect(\n      pipe(\n        data,\n        filter(isDefined),\n        map((data2) => data2 == null ? void 0 : data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        listState,\n        map((value) => value.topListHeight)\n      ),\n      topListHeight\n    );\n    connect(topListHeight, rangeTopListHeight);\n    connect(\n      pipe(\n        listState,\n        map((state) => [state.top, state.bottom])\n      ),\n      listBoundary\n    );\n    connect(\n      pipe(\n        listState,\n        map((state) => state.items)\n      ),\n      itemsRendered\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, data),\n        filter(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),\n        map(([, totalCount2, data2]) => [totalCount2 - 1, data2]),\n        distinctUntilChanged(tupleComparator),\n        map(([count]) => count)\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        listState,\n        throttleTime(200),\n        filter(({ items, topItems }) => {\n          return items.length > 0 && items[0].originalIndex === topItems.length;\n        }),\n        map(({ items }) => items[0].index),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        map(({ items }) => {\n          let startIndex = 0;\n          let endIndex = items.length - 1;\n          while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n            startIndex++;\n          }\n          while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n            endIndex--;\n          }\n          return {\n            startIndex: items[startIndex].index,\n            endIndex: items[endIndex].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator)\n      )\n    );\n    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, ...stateFlags };\n  },\n  tup(\n    sizeSystem,\n    groupedListSystem,\n    sizeRangeSystem,\n    initialTopMostItemIndexSystem,\n    scrollToIndexSystem,\n    stateFlagsSystem,\n    propsReadySystem,\n    recalcSystem\n  ),\n  { singleton: true }\n);\nconst initialItemCountSystem = system(\n  ([{ sizes, firstItemIndex, data, gap }, { listState }, { didMount }]) => {\n    const initialItemCount = statefulStream(0);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialItemCount),\n        filter(([, count]) => count !== 0),\n        withLatestFrom(sizes, firstItemIndex, gap, data),\n        map(([[, count], sizes2, firstItemIndex2, gap2, data2 = []]) => {\n          let includedGroupsCount = 0;\n          if (sizes2.groupIndices.length > 0) {\n            for (const index of sizes2.groupIndices) {\n              if (index - includedGroupsCount >= count) {\n                break;\n              }\n              includedGroupsCount++;\n            }\n          }\n          const adjustedCount = count + includedGroupsCount;\n          const items = Array.from({ length: adjustedCount }).map((_, index) => ({ index, size: 0, offset: 0, data: data2[index] }));\n          return buildListState(items, [], adjustedCount, gap2, sizes2, firstItemIndex2);\n        })\n      ),\n      listState\n    );\n    return { initialItemCount };\n  },\n  tup(sizeSystem, listStateSystem, propsReadySystem),\n  { singleton: true }\n);\nconst scrollSeekSystem = system(\n  ([{ scrollVelocity }]) => {\n    const isSeeking = statefulStream(false);\n    const rangeChanged = stream();\n    const scrollSeekConfiguration = statefulStream(false);\n    connect(\n      pipe(\n        scrollVelocity,\n        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),\n        filter(([_, config]) => !!config),\n        map(([speed, config, isSeeking2, range]) => {\n          const { exit, enter } = config;\n          if (isSeeking2) {\n            if (exit(speed, range)) {\n              return false;\n            }\n          } else {\n            if (enter(speed, range)) {\n              return true;\n            }\n          }\n          return isSeeking2;\n        }),\n        distinctUntilChanged()\n      ),\n      isSeeking\n    );\n    subscribe(\n      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),\n      ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range)\n    );\n    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };\n  },\n  tup(stateFlagsSystem),\n  { singleton: true }\n);\nconst topItemCountSystem = system(([{ topItemsIndexes }]) => {\n  const topItemCount = statefulStream(0);\n  connect(\n    pipe(\n      topItemCount,\n      filter((length) => length > 0),\n      map((length) => Array.from({ length }).map((_, index) => index))\n    ),\n    topItemsIndexes\n  );\n  return { topItemCount };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(\n  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {\n    const totalListHeightChanged = stream();\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),\n        map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {\n          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(duc(totalListHeight), totalListHeightChanged);\n    return { totalListHeight, totalListHeightChanged };\n  },\n  tup(domIOSystem, listStateSystem),\n  { singleton: true }\n);\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(\n  ([\n    { scrollBy, scrollTop, deviation, scrollingInProgress },\n    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },\n    { listState },\n    { beforeUnshiftWith, shiftWithOffset, sizes, gap },\n    { log },\n    { recalcInProgress }\n  ]) => {\n    const deviationOffset = streamFromEmitter(\n      pipe(\n        listState,\n        withLatestFrom(lastJumpDueToItemResize),\n        scan(\n          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2]) => {\n            const totalHeight = bottom + offsetBottom;\n            let newDev = 0;\n            if (prevTotalCount === totalCount) {\n              if (prevItems.length > 0 && items.length > 0) {\n                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n                if (!atStart) {\n                  newDev = totalHeight - prevTotalHeight;\n                  if (newDev !== 0) {\n                    newDev += lastJumpDueToItemResize2;\n                  }\n                }\n              }\n            }\n            return [newDev, items, totalCount, totalHeight];\n          },\n          [0, [], 0, 0]\n        ),\n        filter(([amount]) => amount !== 0),\n        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress),\n        filter(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2]) => {\n          return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n        }),\n        map(([[amount], , , , , log2]) => {\n          log2(\"Upward scrolling compensation\", { amount }, LogLevel.DEBUG);\n          return amount;\n        })\n      )\n    );\n    function scrollByWith(offset) {\n      if (offset > 0) {\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n        publish(deviation, 0);\n      } else {\n        publish(deviation, 0);\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n      }\n    }\n    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {\n      if (isScrolling2 && isMobileSafari()) {\n        publish(deviation, deviationAmount - offset);\n      } else {\n        scrollByWith(-offset);\n      }\n    });\n    subscribe(\n      pipe(\n        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),\n        filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0),\n        map(([_, deviation2]) => deviation2),\n        throttleTime(1)\n      ),\n      scrollByWith\n    );\n    connect(\n      pipe(\n        shiftWithOffset,\n        map((offset) => {\n          return { top: -offset };\n        })\n      ),\n      scrollBy\n    );\n    subscribe(\n      pipe(\n        beforeUnshiftWith,\n        withLatestFrom(sizes, gap),\n        map(([offset, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap2]) => {\n          function getItemOffset(itemCount) {\n            return itemCount * (defaultItemSize + gap2);\n          }\n          if (groupIndices.length === 0) {\n            return getItemOffset(offset);\n          } else {\n            let amount = 0;\n            const defaultGroupSize = find(sizeTree, 0);\n            let recognizedOffsetItems = 0;\n            let groupIndex = 0;\n            while (recognizedOffsetItems < offset) {\n              recognizedOffsetItems++;\n              amount += defaultGroupSize;\n              let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n              if (recognizedOffsetItems + groupItemCount > offset) {\n                amount -= defaultGroupSize;\n                groupItemCount = offset - recognizedOffsetItems + 1;\n              }\n              recognizedOffsetItems += groupItemCount;\n              amount += getItemOffset(groupItemCount);\n              groupIndex++;\n            }\n            return amount;\n          }\n        })\n      ),\n      (offset) => {\n        publish(deviation, offset);\n        requestAnimationFrame(() => {\n          publish(scrollBy, { top: offset });\n          requestAnimationFrame(() => {\n            publish(deviation, 0);\n            publish(recalcInProgress, false);\n          });\n        });\n      }\n    );\n    return { deviation };\n  },\n  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)\n);\nconst initialScrollTopSystem = system(\n  ([{ didMount }, { scrollTo }, { listState }]) => {\n    const initialScrollTop = statefulStream(0);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialScrollTop),\n        filter(([, offset]) => offset !== 0),\n        map(([, offset]) => ({ top: offset }))\n      ),\n      (location) => {\n        handleNext(\n          pipe(\n            listState,\n            skip(1),\n            filter((state) => state.items.length > 1)\n          ),\n          () => {\n            requestAnimationFrame(() => {\n              publish(scrollTo, location);\n            });\n          }\n        );\n      }\n    );\n    return {\n      initialScrollTop\n    };\n  },\n  tup(propsReadySystem, domIOSystem, listStateSystem),\n  { singleton: true }\n);\nconst alignToBottomSystem = system(\n  ([{ viewportHeight }, { totalListHeight }]) => {\n    const alignToBottom = statefulStream(false);\n    const paddingTopAddition = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(alignToBottom, viewportHeight, totalListHeight),\n        filter(([enabled]) => enabled),\n        map(([, viewportHeight2, totalListHeight2]) => {\n          return Math.max(0, viewportHeight2 - totalListHeight2);\n        }),\n        throttleTime(0),\n        distinctUntilChanged()\n      ),\n      0\n    );\n    return { alignToBottom, paddingTopAddition };\n  },\n  tup(domIOSystem, totalListHeightSystem),\n  { singleton: true }\n);\nconst windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(\n    pipe(\n      combineLatest(windowScrollContainerState, windowViewportRect),\n      map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {\n        return {\n          scrollTop: Math.max(0, windowScrollTop - offsetTop),\n          scrollHeight,\n          viewportHeight\n        };\n      })\n    ),\n    scrollContainerState\n  );\n  connect(\n    pipe(\n      scrollTo,\n      withLatestFrom(windowViewportRect),\n      map(([scrollTo2, { offsetTop }]) => {\n        return {\n          ...scrollTo2,\n          top: scrollTo2.top + offsetTop\n        };\n      })\n    ),\n    windowScrollTo\n  );\n  return {\n    // config\n    useWindowScroll,\n    customScrollParent,\n    // input\n    windowScrollContainerState,\n    windowViewportRect,\n    // signals\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = ({\n  itemTop: itemTop2,\n  itemBottom,\n  viewportTop,\n  viewportBottom,\n  locationParams: { behavior, align, ...rest }\n}) => {\n  if (itemTop2 < viewportTop) {\n    return { ...rest, behavior, align: align != null ? align : \"start\" };\n  }\n  if (itemBottom > viewportBottom) {\n    return { ...rest, behavior, align: align != null ? align : \"end\" };\n  }\n  return null;\n};\nconst scrollIntoViewSystem = system(\n  ([\n    { sizes, totalCount, gap },\n    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },\n    { scrollToIndex }\n  ]) => {\n    const scrollIntoView = stream();\n    connect(\n      pipe(\n        scrollIntoView,\n        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),\n        withLatestFrom(gap),\n        map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {\n          const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest } = viewLocation;\n          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n          const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n          const viewportTop = scrollTop2 + fixedHeaderHeight2;\n          const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n          const location = calculateViewLocation({\n            itemTop: itemTop2,\n            itemBottom,\n            viewportTop,\n            viewportBottom,\n            locationParams: { behavior, align, ...rest }\n          });\n          if (location) {\n            done && handleNext(\n              pipe(\n                scrollingInProgress,\n                filter((value) => value === false),\n                // skips the initial publish of false, and the cleanup call.\n                // but if scrollingInProgress is true, we skip the initial publish.\n                skip(getValue(scrollingInProgress) ? 1 : 2)\n              ),\n              done\n            );\n          } else {\n            done && done();\n          }\n          return location;\n        }),\n        filter((value) => value !== null)\n      ),\n      scrollToIndex\n    );\n    return {\n      scrollIntoView\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),\n  { singleton: true }\n);\nconst stateLoadSystem = system(([{ sizes, sizeRanges }, { scrollTop }, { initialTopMostItemIndex }, { didMount }]) => {\n  const getState = stream();\n  const restoreStateFrom = statefulStream(void 0);\n  subscribe(pipe(getState, withLatestFrom(sizes, scrollTop)), ([callback, sizes2, scrollTop2]) => {\n    const ranges = sizeTreeToRanges(sizes2.sizeTree);\n    callback({ ranges, scrollTop: scrollTop2 });\n  });\n  connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n  connect(\n    pipe(\n      didMount,\n      withLatestFrom(restoreStateFrom),\n      filter(([, state]) => state !== void 0),\n      distinctUntilChanged(),\n      map(([, snapshot]) => {\n        return snapshot.ranges;\n      })\n    ),\n    sizeRanges\n  );\n  return {\n    getState,\n    restoreStateFrom\n  };\n}, tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem));\nfunction locationFromSnapshot(snapshot) {\n  return { offset: snapshot.scrollTop, index: 0, align: \"start\" };\n}\nconst featureGroup1System = system(\n  ([\n    sizeRange,\n    initialItemCount,\n    propsReady,\n    scrollSeek,\n    totalListHeight,\n    initialScrollTopSystem2,\n    alignToBottom,\n    windowScroller,\n    scrollIntoView,\n    logger\n  ]) => {\n    return {\n      ...sizeRange,\n      ...initialItemCount,\n      ...propsReady,\n      ...scrollSeek,\n      ...totalListHeight,\n      ...initialScrollTopSystem2,\n      ...alignToBottom,\n      ...windowScroller,\n      ...scrollIntoView,\n      ...logger\n    };\n  },\n  tup(\n    sizeRangeSystem,\n    initialItemCountSystem,\n    propsReadySystem,\n    scrollSeekSystem,\n    totalListHeightSystem,\n    initialScrollTopSystem,\n    alignToBottomSystem,\n    windowScrollerSystem,\n    scrollIntoViewSystem,\n    loggerSystem\n  )\n);\nconst listSystem = system(\n  ([\n    {\n      totalCount,\n      sizeRanges,\n      fixedItemSize,\n      defaultItemSize,\n      trackItemSizes,\n      itemSize,\n      data,\n      firstItemIndex,\n      groupIndices,\n      statefulTotalCount,\n      gap,\n      sizes\n    },\n    { initialTopMostItemIndex, scrolledToInitialItem },\n    domIO,\n    stateLoad,\n    followOutput,\n    { listState, topItemsIndexes, ...flags },\n    { scrollToIndex },\n    _,\n    { topItemCount },\n    { groupCounts },\n    featureGroup1\n  ]) => {\n    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        featureGroup1.windowViewportRect,\n        map((value) => value.visibleHeight)\n      ),\n      domIO.viewportHeight\n    );\n    return {\n      // input\n      totalCount,\n      data,\n      firstItemIndex,\n      sizeRanges,\n      initialTopMostItemIndex,\n      scrolledToInitialItem,\n      topItemsIndexes,\n      topItemCount,\n      groupCounts,\n      fixedItemHeight: fixedItemSize,\n      defaultItemHeight: defaultItemSize,\n      gap,\n      ...followOutput,\n      // output\n      statefulTotalCount,\n      listState,\n      scrollToIndex,\n      trackItemSizes,\n      itemSize,\n      groupIndices,\n      // exported from stateFlagsSystem\n      ...flags,\n      // the bag of IO from featureGroup1System\n      ...featureGroup1,\n      ...domIO,\n      sizes,\n      ...stateLoad\n    };\n  },\n  tup(\n    sizeSystem,\n    initialTopMostItemIndexSystem,\n    domIOSystem,\n    stateLoadSystem,\n    followOutputSystem,\n    listStateSystem,\n    scrollToIndexSystem,\n    upwardScrollFixSystem,\n    topItemCountSystem,\n    groupedListSystem,\n    featureGroup1System\n  )\n);\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent) {\n  const viewportInfo = React.useRef(null);\n  const calculateInfo = React.useCallback(\n    (element) => {\n      if (element === null || !element.offsetParent) {\n        return;\n      }\n      const rect = element.getBoundingClientRect();\n      const visibleWidth = rect.width;\n      let visibleHeight, offsetTop;\n      if (customScrollParent) {\n        const customScrollParentRect = customScrollParent.getBoundingClientRect();\n        const deltaTop = rect.top - customScrollParentRect.top;\n        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n        offsetTop = deltaTop + customScrollParent.scrollTop;\n      } else {\n        visibleHeight = window.innerHeight - Math.max(0, rect.top);\n        offsetTop = rect.top + window.pageYOffset;\n      }\n      viewportInfo.current = {\n        offsetTop,\n        visibleHeight,\n        visibleWidth\n      };\n      callback(viewportInfo.current);\n    },\n    [callback, customScrollParent]\n  );\n  const { callbackRef, ref } = useSizeWithElRef(calculateInfo);\n  const scrollAndResizeEventHandler = React.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  React.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(scrollAndResizeEventHandler);\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = React.createContext(void 0);\nconst VirtuosoGridMockContext = React.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream((index) => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({ height }) => /* @__PURE__ */ React.createElement(\"div\", { style: { height } });\nconst GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1, overflowAnchor: \"none\" };\nconst ITEM_STYLE$1 = { overflowAnchor: \"none\" };\nconst Items$1 = /* @__PURE__ */ React.memo(function VirtuosoItems({ showTopList = false }) {\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const { callbackRef } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    showTopList ? noop : scrollContainerStateCallback,\n    log,\n    listGap,\n    customScrollParent\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter$2(\"deviation\", (value) => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const paddingTopAddition = useEmitterValue$2(\"paddingTopAddition\");\n  const scrolledToInitialItem = useEmitterValue$2(\"scrolledToInitialItem\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    paddingTop: listState.offsetTop + paddingTopAddition,\n    paddingBottom: listState.offsetBottom,\n    marginTop: deviation,\n    ...scrolledToInitialItem ? {} : { visibility: \"hidden\" }\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  return React.createElement(\n    ListComponent,\n    {\n      ...contextPropIfNotDomElement(ListComponent, context),\n      ref: callbackRef,\n      style: containerStyle,\n      \"data-test-id\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\"\n    },\n    (showTopList ? listState.topItems : listState.items).map((item) => {\n      const index = item.originalIndex;\n      const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n      if (isSeeking) {\n        return React.createElement(ScrollSeekPlaceholder, {\n          ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n          key,\n          index: item.index,\n          height: item.size,\n          type: item.type || \"item\",\n          ...item.type === \"group\" ? {} : { groupIndex: item.groupIndex }\n        });\n      }\n      if (item.type === \"group\") {\n        return React.createElement(\n          GroupComponent,\n          {\n            ...contextPropIfNotDomElement(GroupComponent, context),\n            key,\n            \"data-index\": index,\n            \"data-known-size\": item.size,\n            \"data-item-index\": item.index,\n            style: GROUP_STYLE\n          },\n          groupContent(item.index, context)\n        );\n      } else {\n        return React.createElement(\n          ItemComponent,\n          {\n            ...contextPropIfNotDomElement(ItemComponent, context),\n            key,\n            \"data-index\": index,\n            \"data-known-size\": item.size,\n            \"data-item-index\": item.index,\n            \"data-item-group-index\": item.groupIndex,\n            item: item.data,\n            style: ITEM_STYLE$1\n          },\n          hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context)\n        );\n      }\n    })\n  );\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst viewportStyle = {\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0\n};\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return { context };\n}\nconst Header$1 = /* @__PURE__ */ React.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize((el) => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer$1 = /* @__PURE__ */ React.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$2(\"headerFooterTag\");\n  const ref = useSize((el) => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nfunction buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      scrollerRefCallback\n    );\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(\n      ScrollerComponent,\n      {\n        ref: scrollerRef,\n        style: { ...scrollerStyle, ...style },\n        \"data-test-id\": \"virtuoso-scroller\",\n        \"data-virtuoso-scroller\": true,\n        tabIndex: 0,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context)\n      },\n      children\n    );\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = React.memo(function VirtuosoWindowScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      noop,\n      customScrollParent\n    );\n    useIsomorphicLayoutEffect$1(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return React.createElement(\n      ScrollerComponent,\n      {\n        style: { position: \"relative\", ...style, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },\n        \"data-virtuoso-scroller\": true,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context)\n      },\n      children\n    );\n  });\n  return Scroller2;\n}\nconst Viewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef, \"data-viewport-type\": \"element\" }, children);\n};\nconst WindowViewport$2 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle, \"data-viewport-type\": \"window\" }, children);\n};\nconst TopItemListContainer = ({ children }) => {\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\");\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = { ...topItemListStyle, marginTop: `${headerHeight}px` };\n  const context = useEmitterValue$2(\"context\");\n  return React.createElement(TopItemList || \"div\", { style, context }, children);\n};\nconst ListRoot = /* @__PURE__ */ React.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, showTopList && /* @__PURE__ */ React.createElement(TopItemListContainer, null, /* @__PURE__ */ React.createElement(Items$1, { showTopList: true })), /* @__PURE__ */ React.createElement(TheViewport, null, /* @__PURE__ */ React.createElement(Header$1, null), /* @__PURE__ */ React.createElement(Items$1, null), /* @__PURE__ */ React.createElement(Footer$1, null)));\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$2,\n  {\n    required: {},\n    optional: {\n      restoreStateFrom: \"restoreStateFrom\",\n      context: \"context\",\n      followOutput: \"followOutput\",\n      itemContent: \"itemContent\",\n      groupContent: \"groupContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      groupCounts: \"groupCounts\",\n      topItemCount: \"topItemCount\",\n      firstItemIndex: \"firstItemIndex\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      autoscrollToBottom: \"autoscrollToBottom\",\n      getState: \"getState\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  ListRoot\n);\nconst Scroller$2 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{ index: 0 }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst { round, ceil, floor, min, max } = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({ length: endIndex - startIndex + 1 }).map((_, i) => {\n    const dataItem = data === null ? null : data[i + startIndex];\n    return { index: i + startIndex, data: dataItem };\n  });\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */ system(\n  ([\n    { overscan, visibleRange, listBoundary },\n    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },\n    stateFlags,\n    scrollSeek,\n    { propsReady, didMount },\n    { windowViewportRect, useWindowScroll, customScrollParent, windowScrollContainerState, windowScrollTo },\n    log\n  ]) => {\n    const totalCount = statefulStream(0);\n    const initialItemCount = statefulStream(0);\n    const gridState = statefulStream(INITIAL_GRID_STATE);\n    const viewportDimensions = statefulStream({ height: 0, width: 0 });\n    const itemDimensions = statefulStream({ height: 0, width: 0 });\n    const scrollToIndex = stream();\n    const scrollHeight = stream();\n    const deviation = statefulStream(0);\n    const data = statefulStream(null);\n    const gap = statefulStream({ row: 0, column: 0 });\n    const stateChanged = stream();\n    const restoreStateFrom = stream();\n    const stateRestoreInProgress = statefulStream(false);\n    const initialTopMostItemIndex = statefulStream(0);\n    const scrolledToInitialItem = statefulStream(true);\n    const scrollScheduled = statefulStream(false);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location)\n      ),\n      () => {\n        publish(scrolledToInitialItem, false);\n        publish(initialItemCount, 0);\n      }\n    );\n    subscribe(\n      pipe(\n        combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled),\n        filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2, , scrollScheduled2]) => {\n          return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;\n        })\n      ),\n      ([, , , , initialTopMostItemIndex2]) => {\n        publish(scrollScheduled, true);\n        skipFrames(1, () => {\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n        handleNext(pipe(scrollTop), () => {\n          publish(listBoundary, [0, 0]);\n          publish(scrolledToInitialItem, true);\n        });\n      }\n    );\n    connect(\n      pipe(\n        restoreStateFrom,\n        filter((value) => value !== void 0 && value !== null && value.scrollTop > 0),\n        mapTo(0)\n      ),\n      initialItemCount\n    );\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(restoreStateFrom),\n        filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)\n      ),\n      ([, snapshot]) => {\n        if (!snapshot) {\n          return;\n        }\n        publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);\n        publish(gap, snapshot.gap);\n        if (snapshot.scrollTop > 0) {\n          publish(stateRestoreInProgress, true);\n          handleNext(pipe(scrollTop, skip(1)), (_value) => {\n            publish(stateRestoreInProgress, false);\n          });\n          publish(scrollTo, { top: snapshot.scrollTop });\n        }\n      }\n    );\n    connect(\n      pipe(\n        viewportDimensions,\n        map(({ height }) => height)\n      ),\n      viewportHeight\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(viewportDimensions, dimensionComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row),\n          duc(scrollTop)\n        ),\n        map(([viewport, item, gap2, scrollTop2]) => ({\n          viewport,\n          item,\n          gap: gap2,\n          scrollTop: scrollTop2\n        }))\n      ),\n      stateChanged\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(totalCount),\n          visibleRange,\n          duc(gap, gapComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(viewportDimensions, dimensionComparator),\n          duc(data),\n          duc(initialItemCount),\n          duc(stateRestoreInProgress),\n          duc(scrolledToInitialItem),\n          duc(initialTopMostItemIndex)\n        ),\n        filter(([, , , , , , , stateRestoreInProgress2]) => {\n          return !stateRestoreInProgress2;\n        }),\n        map(\n          ([\n            totalCount2,\n            [startOffset, endOffset],\n            gap2,\n            item,\n            viewport,\n            data2,\n            initialItemCount2,\n            ,\n            scrolledToInitialItem2,\n            initialTopMostItemIndex2\n          ]) => {\n            const { row: rowGap, column: columnGap } = gap2;\n            const { height: itemHeight, width: itemWidth } = item;\n            const { width: viewportWidth } = viewport;\n            if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {\n              return INITIAL_GRID_STATE;\n            }\n            if (itemWidth === 0) {\n              const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);\n              const endIndex2 = startIndex2 === 0 ? Math.max(initialItemCount2 - 1, 0) : startIndex2;\n              return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));\n            }\n            const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n            let startIndex;\n            let endIndex;\n            if (!scrolledToInitialItem2) {\n              startIndex = 0;\n              endIndex = -1;\n            } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {\n              startIndex = 0;\n              endIndex = initialItemCount2 - 1;\n            } else {\n              startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n              endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n              endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n              startIndex = min(endIndex, max(0, startIndex));\n            }\n            const items = buildItems(startIndex, endIndex, data2);\n            const { top, bottom } = gridLayout(viewport, gap2, item, items);\n            const rowCount = ceil(totalCount2 / perRow);\n            const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n            const offsetBottom = totalHeight - bottom;\n            return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth };\n          }\n        )\n      ),\n      gridState\n    );\n    connect(\n      pipe(\n        data,\n        filter((data2) => data2 !== null),\n        map((data2) => data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        combineLatest(viewportDimensions, itemDimensions, gridState, gap),\n        filter(([viewportDimensions2, itemDimensions2, { items }]) => {\n          return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;\n        }),\n        map(([viewportDimensions2, itemDimensions2, { items }, gap2]) => {\n          const { top, bottom } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);\n          return [top, bottom];\n        }),\n        distinctUntilChanged(tupleComparator)\n      ),\n      listBoundary\n    );\n    const hasScrolled = statefulStream(false);\n    connect(\n      pipe(\n        scrollTop,\n        withLatestFrom(hasScrolled),\n        map(([scrollTop2, hasScrolled2]) => {\n          return hasScrolled2 || scrollTop2 !== 0;\n        })\n      ),\n      hasScrolled\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, hasScrolled),\n        filter(([{ items }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1),\n        map(([, totalCount2]) => totalCount2 - 1),\n        distinctUntilChanged()\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => {\n          return items.length > 0 && items[0].index === 0;\n        }),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(0),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        withLatestFrom(stateRestoreInProgress),\n        filter(([{ items }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2),\n        map(([{ items }]) => {\n          return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator),\n        throttleTime(0)\n      )\n    );\n    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap),\n        map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {\n          const normalLocation = normalizeIndexLocation(location);\n          const { align, behavior, offset } = normalLocation;\n          let index = normalLocation.index;\n          if (index === \"LAST\") {\n            index = totalCount2 - 1;\n          }\n          index = max(0, index, min(totalCount2 - 1, index));\n          let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);\n          if (align === \"end\") {\n            top = round(top - viewportDimensions2.height + itemDimensions2.height);\n          } else if (align === \"center\") {\n            top = round(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);\n          }\n          if (offset) {\n            top += offset;\n          }\n          return { top, behavior };\n        })\n      ),\n      scrollTo\n    );\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        gridState,\n        map((gridState2) => {\n          return gridState2.offsetBottom + gridState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(\n      pipe(\n        windowViewportRect,\n        map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))\n      ),\n      viewportDimensions\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      viewportDimensions,\n      itemDimensions,\n      scrollTop,\n      scrollHeight,\n      overscan,\n      scrollBy,\n      scrollTo,\n      scrollToIndex,\n      smoothScrollTargetReached,\n      windowViewportRect,\n      windowScrollTo,\n      useWindowScroll,\n      customScrollParent,\n      windowScrollContainerState,\n      deviation,\n      scrollContainerState,\n      footerHeight,\n      headerHeight,\n      initialItemCount,\n      gap,\n      restoreStateFrom,\n      ...scrollSeek,\n      initialTopMostItemIndex,\n      // output\n      gridState,\n      totalListHeight,\n      ...stateFlags,\n      startReached,\n      endReached,\n      rangeChanged,\n      stateChanged,\n      propsReady,\n      stateRestoreInProgress,\n      ...log\n    };\n  },\n  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)\n);\nfunction gridLayout(viewport, gap, item, items) {\n  const { height: itemHeight } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return { top: 0, bottom: 0 };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return { top, bottom };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {\n  return { ...gridSystem2, ...gridComponentPropsSystem2 };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */ React.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const stateRestoreInProgress = useEmitterValue$1(\"stateRestoreInProgress\");\n  const listRef = useSize((el) => {\n    const scrollHeight = el.parentElement.parentElement.scrollHeight;\n    scrollHeightCallback(scrollHeight);\n    const firstItem = el.firstChild;\n    if (firstItem) {\n      const { width, height } = firstItem.getBoundingClientRect();\n      itemDimensions({ width, height });\n    }\n    gridGap({\n      row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n      column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n    });\n  });\n  if (stateRestoreInProgress) {\n    return null;\n  }\n  return React.createElement(\n    ListComponent,\n    {\n      ref: listRef,\n      className: listClassName,\n      ...contextPropIfNotDomElement(ListComponent, context),\n      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },\n      \"data-test-id\": \"virtuoso-item-list\"\n    },\n    gridState.items.map((item) => {\n      const key = computeItemKey(item.index, item.data, context);\n      return isSeeking ? React.createElement(ScrollSeekPlaceholder, {\n        key,\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        index: item.index,\n        height: gridState.itemHeight,\n        width: gridState.itemWidth\n      }) : React.createElement(\n        ItemComponent,\n        { ...contextPropIfNotDomElement(ItemComponent, context), className: itemClassName, \"data-index\": item.index, key },\n        itemContent(item.index, item.data, context)\n      );\n    })\n  );\n});\nconst Header = React.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize((el) => headerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Header2, contextPropIfNotDomElement(Header2, context))) : null;\n});\nconst Footer = React.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const headerFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize((el) => footerHeight(correctItemSize(el, \"height\")));\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? React.createElement(headerFooterTag, { ref }, React.createElement(Footer2, contextPropIfNotDomElement(Footer2, context))) : null;\n});\nconst Viewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize((el) => {\n    viewportDimensions(el.getBoundingClientRect());\n  });\n  React.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({ height: ctx.viewportHeight, width: ctx.viewportWidth });\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef }, children);\n};\nconst WindowViewport$1 = ({ children }) => {\n  const ctx = React.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: ctx.viewportWidth });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle }, children);\n};\nconst GridRoot = /* @__PURE__ */ React.memo(function GridRoot2({ ...props }) {\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, /* @__PURE__ */ React.createElement(TheViewport, null, /* @__PURE__ */ React.createElement(Header, null), /* @__PURE__ */ React.createElement(GridItems, null), /* @__PURE__ */ React.createElement(Footer, null)));\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$1,\n  {\n    optional: {\n      context: \"context\",\n      totalCount: \"totalCount\",\n      overscan: \"overscan\",\n      itemContent: \"itemContent\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      listClassName: \"listClassName\",\n      itemClassName: \"itemClassName\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\",\n      restoreStateFrom: \"restoreStateFrom\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\"\n    },\n    methods: {\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      stateChanged: \"stateChanged\"\n    }\n  },\n  GridRoot\n);\nconst Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nconst WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => /* @__PURE__ */ React.createElement(\"td\", null, \"Item $\", index));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({ height }) => /* @__PURE__ */ React.createElement(\"tr\", null, /* @__PURE__ */ React.createElement(\"td\", { style: { height } }));\nconst DefaultFillerRow = ({ height }) => /* @__PURE__ */ React.createElement(\"tr\", null, /* @__PURE__ */ React.createElement(\"td\", { style: { height, padding: 0, border: 0 } }));\nconst ITEM_STYLE = { overflowAnchor: \"none\" };\nconst Items = /* @__PURE__ */ React.memo(function VirtuosoItems2() {\n  const listState = useEmitterValue(\"listState\");\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue(\"itemContent\");\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const { callbackRef, ref } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    scrollContainerStateCallback,\n    log,\n    void 0,\n    customScrollParent\n  );\n  const [deviation, setDeviation] = React.useState(0);\n  useEmitter(\"deviation\", (value) => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return React.createElement(EmptyPlaceholder, contextPropIfNotDomElement(EmptyPlaceholder, context));\n  }\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ React.createElement(FillerRow, { height: paddingTop, key: \"padding-top\", context }) : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ React.createElement(FillerRow, { height: paddingBottom, key: \"padding-bottom\", context }) : null;\n  const items = listState.items.map((item) => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    if (isSeeking) {\n      return React.createElement(ScrollSeekPlaceholder, {\n        ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n        key,\n        index: item.index,\n        height: item.size,\n        type: item.type || \"item\"\n      });\n    }\n    return React.createElement(\n      TableRowComponent,\n      {\n        ...contextPropIfNotDomElement(TableRowComponent, context),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        item: item.data,\n        style: ITEM_STYLE\n      },\n      itemContent(item.index, item.data, context)\n    );\n  });\n  return React.createElement(\n    TableBodyComponent,\n    { ref: callbackRef, \"data-test-id\": \"virtuoso-item-list\", ...contextPropIfNotDomElement(TableBodyComponent, context) },\n    [paddingTopEl, ...items, paddingBottomEl]\n  );\n});\nconst Viewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(compose(viewportHeight, (el) => correctItemSize(el, \"height\")));\n  React.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { style: viewportStyle, ref: viewportRef, \"data-viewport-type\": \"element\" }, children);\n};\nconst WindowViewport = ({ children }) => {\n  const ctx = React.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent);\n  React.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ React.createElement(\"div\", { ref: viewportRef, style: viewportStyle, \"data-viewport-type\": \"window\" }, children);\n};\nconst TableRoot = /* @__PURE__ */ React.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(compose(fixedHeaderHeight, (el) => correctItemSize(el, \"height\")));\n  const tfootRef = useSize(compose(fixedFooterHeight, (el) => correctItemSize(el, \"height\")));\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? React.createElement(\n    TheTHead,\n    {\n      key: \"TableHead\",\n      style: { zIndex: 2, position: \"sticky\", top: 0 },\n      ref: theadRef,\n      ...contextPropIfNotDomElement(TheTHead, context)\n    },\n    fixedHeaderContent()\n  ) : null;\n  const theFoot = fixedFooterContent ? React.createElement(\n    TheTFoot,\n    {\n      key: \"TableFoot\",\n      style: { zIndex: 1, position: \"sticky\", bottom: 0 },\n      ref: tfootRef,\n      ...contextPropIfNotDomElement(TheTFoot, context)\n    },\n    fixedFooterContent()\n  ) : null;\n  return /* @__PURE__ */ React.createElement(TheScroller, { ...props }, /* @__PURE__ */ React.createElement(TheViewport, null, React.createElement(\n    TheTable,\n    { style: { borderSpacing: 0, overflowAnchor: \"none\" }, ...contextPropIfNotDomElement(TheTable, context) },\n    [theHead, /* @__PURE__ */ React.createElement(Items, { key: \"TableBody\" }), theFoot]\n  )));\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem,\n  {\n    required: {},\n    optional: {\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedFooterContent: \"fixedFooterContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  TableRoot\n);\nconst Scroller = /* @__PURE__ */ buildScroller({ usePublisher, useEmitterValue, useEmitter });\nconst WindowScroller = /* @__PURE__ */ buildWindowScroller({ usePublisher, useEmitterValue, useEmitter });\nconst TableVirtuoso = Table;\nexport {\n  GroupedVirtuoso,\n  LogLevel,\n  TableVirtuoso,\n  Virtuoso,\n  VirtuosoGrid,\n  VirtuosoGridMockContext,\n  VirtuosoMockContext\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}